{"version":3,"sources":["../src/constants.ts","../src/errors.ts","../src/path-utils.ts","../src/handle-manager.ts","../src/symlink-manager.ts","../src/file-handle.ts","../src/streams.ts","../src/index.ts","../src/opfs-worker-proxy.ts","../src/opfs-hybrid.ts"],"names":["position","name"],"mappings":"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","file":"opfs-hybrid.js","sourcesContent":["import type { FSConstants } from './types.js'\n\n/**\n * File system constants matching Node.js fs.constants\n */\nexport const constants: FSConstants = {\n  // File access modes\n  F_OK: 0,\n  R_OK: 4,\n  W_OK: 2,\n  X_OK: 1,\n\n  // Copy file flags\n  COPYFILE_EXCL: 1,\n  COPYFILE_FICLONE: 2,\n  COPYFILE_FICLONE_FORCE: 4,\n\n  // File open flags\n  O_RDONLY: 0,\n  O_WRONLY: 1,\n  O_RDWR: 2,\n  O_CREAT: 64,\n  O_EXCL: 128,\n  O_TRUNC: 512,\n  O_APPEND: 1024,\n\n  // File type masks\n  S_IFMT: 61440,\n  S_IFREG: 32768,\n  S_IFDIR: 16384,\n  S_IFLNK: 40960\n}\n\n/**\n * Convert numeric flags to string representation\n */\nexport function flagsToString(flags: number | string): string {\n  if (typeof flags === 'string') return flags\n\n  const map: Record<number, string> = {\n    [constants.O_RDONLY]: 'r',\n    [constants.O_WRONLY]: 'w',\n    [constants.O_RDWR]: 'r+',\n    [constants.O_CREAT | constants.O_WRONLY]: 'w',\n    [constants.O_CREAT | constants.O_WRONLY | constants.O_TRUNC]: 'w',\n    [constants.O_CREAT | constants.O_RDWR]: 'w+',\n    [constants.O_APPEND | constants.O_WRONLY]: 'a',\n    [constants.O_APPEND | constants.O_RDWR]: 'a+'\n  }\n\n  return map[flags] || 'r'\n}\n","/**\n * Custom error class for filesystem errors\n */\nexport class FSError extends Error {\n  code: string\n  syscall?: string\n  path?: string\n  original?: Error\n\n  constructor(message: string, code: string, options?: { syscall?: string; path?: string; original?: Error }) {\n    super(message)\n    this.name = 'FSError'\n    this.code = code\n    this.syscall = options?.syscall\n    this.path = options?.path\n    this.original = options?.original\n  }\n}\n\n/**\n * Create ENOENT (No such file or directory) error\n */\nexport function createENOENT(path: string): FSError {\n  return new FSError(`ENOENT: No such file or directory, '${path}'`, 'ENOENT', { path })\n}\n\n/**\n * Create EEXIST (File exists) error\n */\nexport function createEEXIST(path: string, operation?: string): FSError {\n  const message = operation\n    ? `EEXIST: file already exists, ${operation} '${path}'`\n    : `EEXIST: File exists, '${path}'`\n  return new FSError(message, 'EEXIST', { path })\n}\n\n/**\n * Create EACCES (Permission denied) error\n */\nexport function createEACCES(path: string, syscall?: string): FSError {\n  return new FSError(`EACCES: permission denied, access '${path}'`, 'EACCES', { syscall, path })\n}\n\n/**\n * Create EISDIR (Is a directory) error\n */\nexport function createEISDIR(path: string, operation = 'operation'): FSError {\n  return new FSError(`EISDIR: illegal operation on a directory, ${operation} '${path}'`, 'EISDIR', { path })\n}\n\n/**\n * Create ELOOP (Too many symbolic links) error\n */\nexport function createELOOP(path: string): FSError {\n  return new FSError(`ELOOP: Too many symbolic links, '${path}'`, 'ELOOP', { path })\n}\n\n/**\n * Create EINVAL (Invalid argument) error\n */\nexport function createEINVAL(path: string): FSError {\n  return new FSError(`EINVAL: Invalid argument, '${path}'`, 'EINVAL', { path })\n}\n\n/**\n * Wrap an error with a standard code if it doesn't have one\n */\nexport function wrapError(err: unknown): FSError {\n  if (err instanceof FSError) return err\n\n  const error = err as Error\n  if (typeof (error as FSError).code === 'string') {\n    const fsErr = new FSError(error.message, (error as FSError).code)\n    fsErr.original = error\n    return fsErr\n  }\n\n  const wrapped = new FSError(error.message || 'Unknown error', 'UNKNOWN')\n  wrapped.original = error\n  return wrapped\n}\n","// Path normalization cache - LRU-style with max size\nconst normalizeCache = new Map<string, string>()\nconst CACHE_MAX_SIZE = 1000\n\n/**\n * Normalize a path, handling . and .. components\n * Results are cached for performance on repeated calls\n */\nexport function normalize(path: string | undefined | null): string {\n  if (path === undefined || path === null) {\n    throw new TypeError('Path cannot be undefined or null')\n  }\n\n  if (typeof path !== 'string') {\n    throw new TypeError(`Expected string path, got ${typeof path}`)\n  }\n\n  if (path === '') {\n    return '/'\n  }\n\n  // Check cache first\n  const cached = normalizeCache.get(path)\n  if (cached !== undefined) {\n    return cached\n  }\n\n  const parts = path.split('/')\n  const stack: string[] = []\n\n  for (const part of parts) {\n    if (part === '' || part === '.') {\n      continue\n    } else if (part === '..') {\n      if (stack.length > 0) stack.pop()\n    } else {\n      stack.push(part)\n    }\n  }\n\n  const result = '/' + stack.join('/')\n\n  // Cache the result (simple LRU: clear when full)\n  if (normalizeCache.size >= CACHE_MAX_SIZE) {\n    // Delete oldest entries (first 25%)\n    const deleteCount = CACHE_MAX_SIZE / 4\n    let count = 0\n    for (const key of normalizeCache.keys()) {\n      if (count++ >= deleteCount) break\n      normalizeCache.delete(key)\n    }\n  }\n  normalizeCache.set(path, result)\n\n  return result\n}\n\n/**\n * Get parent directory path\n */\nexport function dirname(path: string): string {\n  const normalized = normalize(path)\n  const parts = normalized.split('/').filter(Boolean)\n  if (parts.length < 2) return '/'\n  return '/' + parts.slice(0, -1).join('/')\n}\n\n/**\n * Get base filename\n */\nexport function basename(path: string): string {\n  const normalized = normalize(path)\n  const parts = normalized.split('/').filter(Boolean)\n  return parts[parts.length - 1] || ''\n}\n\n/**\n * Join path segments\n */\nexport function join(...paths: string[]): string {\n  return normalize(paths.join('/'))\n}\n\n/**\n * Check if path is root\n */\nexport function isRoot(path: string): boolean {\n  const normalized = normalize(path)\n  return normalized === '/' || normalized === ''\n}\n\n/**\n * Get path segments (excluding empty)\n */\nexport function segments(path: string): string[] {\n  return normalize(path).split('/').filter(Boolean)\n}\n","import { normalize, segments, dirname } from './path-utils.js'\nimport { createENOENT } from './errors.js'\n\nexport interface HandleResult {\n  dir: FileSystemDirectoryHandle\n  name: string\n  fileHandle: FileSystemFileHandle | null\n  dirHandle: FileSystemDirectoryHandle | null\n}\n\nexport interface GetHandleOptions {\n  create?: boolean\n  kind?: 'file' | 'directory'\n}\n\nconst FILE_HANDLE_POOL_SIZE = 50\nconst DIR_CACHE_MAX_SIZE = 200\n\n/**\n * Manages OPFS handles with caching for improved performance\n */\nexport class HandleManager {\n  private rootPromise: Promise<FileSystemDirectoryHandle>\n  private dirCache: Map<string, FileSystemDirectoryHandle> = new Map()\n  private fileHandlePool: Map<string, FileSystemFileHandle> = new Map()\n\n  constructor() {\n    this.rootPromise = navigator.storage.getDirectory()\n  }\n\n  /**\n   * Get the root directory handle\n   */\n  async getRoot(): Promise<FileSystemDirectoryHandle> {\n    return this.rootPromise\n  }\n\n  /**\n   * Cache a directory handle with LRU eviction\n   */\n  private cacheDirHandle(path: string, handle: FileSystemDirectoryHandle): void {\n    if (this.dirCache.size >= DIR_CACHE_MAX_SIZE) {\n      // Delete oldest entry (first key in Map maintains insertion order)\n      const firstKey = this.dirCache.keys().next().value\n      if (firstKey) this.dirCache.delete(firstKey)\n    }\n    this.dirCache.set(path, handle)\n  }\n\n  /**\n   * Clear directory cache for a path and its children\n   */\n  clearCache(path = ''): void {\n    const normalizedPath = normalize(path)\n\n    // For root path, just clear everything\n    if (normalizedPath === '/' || normalizedPath === '') {\n      this.dirCache.clear()\n      this.fileHandlePool.clear()\n      return\n    }\n\n    // Clear directory cache\n    if (this.dirCache.size > 0) {\n      for (const key of this.dirCache.keys()) {\n        if (key === normalizedPath || key.startsWith(normalizedPath + '/')) {\n          this.dirCache.delete(key)\n        }\n      }\n    }\n\n    // Clear file handle pool for affected paths\n    if (this.fileHandlePool.size > 0) {\n      for (const key of this.fileHandlePool.keys()) {\n        if (key === normalizedPath || key.startsWith(normalizedPath + '/')) {\n          this.fileHandlePool.delete(key)\n        }\n      }\n    }\n  }\n\n  /**\n   * Get a file handle from the pool or create a new one\n   */\n  async getPooledFileHandle(path: string, create = false): Promise<FileSystemFileHandle | null> {\n    const normalizedPath = normalize(path)\n\n    // Check pool first\n    const pooled = this.fileHandlePool.get(normalizedPath)\n    if (pooled) {\n      return pooled\n    }\n\n    // Get handle the normal way\n    const { fileHandle } = await this.getHandle(normalizedPath, { create })\n    if (!fileHandle) return null\n\n    // Add to pool with LRU eviction\n    if (this.fileHandlePool.size >= FILE_HANDLE_POOL_SIZE) {\n      // Delete oldest entry (first key in Map maintains insertion order)\n      const firstKey = this.fileHandlePool.keys().next().value\n      if (firstKey) this.fileHandlePool.delete(firstKey)\n    }\n    this.fileHandlePool.set(normalizedPath, fileHandle)\n\n    return fileHandle\n  }\n\n  /**\n   * Invalidate a specific file handle from the pool\n   */\n  invalidateFileHandle(path: string): void {\n    const normalizedPath = normalize(path)\n    this.fileHandlePool.delete(normalizedPath)\n  }\n\n  /**\n   * Get file or directory handle for a path\n   */\n  async getHandle(path: string, opts: GetHandleOptions = {}): Promise<HandleResult> {\n    // Use segments() for optimized path parsing (leverages normalize cache)\n    const parts = segments(path)\n\n    // Handle root or empty path\n    if (parts.length === 0) {\n      const root = await this.rootPromise\n      return { dir: root, name: '', fileHandle: null, dirHandle: root }\n    }\n\n    let dir = await this.rootPromise\n    let currentPath = ''\n\n    // Navigate to parent directory using cache\n    for (let i = 0; i < parts.length - 1; i++) {\n      currentPath += '/' + parts[i]\n\n      // Check cache first for better performance\n      if (this.dirCache.has(currentPath)) {\n        dir = this.dirCache.get(currentPath)!\n        continue\n      }\n\n      try {\n        dir = await dir.getDirectoryHandle(parts[i], { create: opts.create })\n        this.cacheDirHandle(currentPath, dir)\n      } catch {\n        throw createENOENT(path)\n      }\n    }\n\n    const name = parts[parts.length - 1]\n\n    try {\n      if (opts.kind === 'directory') {\n        const dirHandle = await dir.getDirectoryHandle(name, { create: opts.create })\n        return { dir, name, fileHandle: null, dirHandle }\n      } else {\n        const fileHandle = await dir.getFileHandle(name, { create: opts.create })\n        return { dir, name, fileHandle, dirHandle: null }\n      }\n    } catch {\n      if (!opts.create) {\n        return { dir, name, fileHandle: null, dirHandle: null }\n      }\n      throw createENOENT(path)\n    }\n  }\n\n  /**\n   * Get directory handle with caching\n   */\n  async getDirectoryHandle(path: string): Promise<FileSystemDirectoryHandle> {\n    const normalizedPath = normalize(path)\n\n    if (normalizedPath === '/' || normalizedPath === '') {\n      return this.rootPromise\n    }\n\n    // Check cache first\n    if (this.dirCache.has(normalizedPath)) {\n      return this.dirCache.get(normalizedPath)!\n    }\n\n    const parts = segments(normalizedPath)\n    let dir = await this.rootPromise\n    let currentPath = ''\n\n    for (const part of parts) {\n      currentPath += '/' + part\n\n      if (this.dirCache.has(currentPath)) {\n        dir = this.dirCache.get(currentPath)!\n        continue\n      }\n\n      dir = await dir.getDirectoryHandle(part)\n      this.cacheDirHandle(currentPath, dir)\n    }\n\n    return dir\n  }\n\n  /**\n   * Ensure parent directory exists\n   */\n  async ensureParentDir(path: string): Promise<void> {\n    const parentPath = dirname(path)\n    if (parentPath === '/' || parentPath === '') return\n\n    const parts = segments(parentPath)\n    let dir = await this.rootPromise\n    let currentPath = ''\n\n    for (const part of parts) {\n      currentPath += '/' + part\n\n      // Check cache first for better performance\n      if (this.dirCache.has(currentPath)) {\n        dir = this.dirCache.get(currentPath)!\n        continue\n      }\n\n      dir = await dir.getDirectoryHandle(part, { create: true })\n      this.cacheDirHandle(currentPath, dir)\n    }\n  }\n\n  /**\n   * Create directory (with automatic parent creation)\n   */\n  async mkdir(path: string): Promise<void> {\n    const normalizedPath = normalize(path)\n    this.clearCache(normalizedPath)\n\n    const parts = segments(normalizedPath)\n    let dir = await this.rootPromise\n\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i]\n      const subPath = '/' + parts.slice(0, i + 1).join('/')\n\n      if (this.dirCache.has(subPath)) {\n        dir = this.dirCache.get(subPath)!\n      } else {\n        dir = await dir.getDirectoryHandle(part, { create: true })\n        this.cacheDirHandle(subPath, dir)\n      }\n    }\n  }\n}\n","import type { SymlinkCache, SymlinkDefinition } from './types.js'\nimport type { HandleManager } from './handle-manager.js'\nimport { normalize } from './path-utils.js'\nimport { createELOOP, createEINVAL, createEEXIST } from './errors.js'\n\nconst SYMLINK_FILE = '/.opfs-symlinks.json'\nconst MAX_SYMLINK_DEPTH = 10\n\n/**\n * Manages symbolic link emulation using a JSON metadata file\n */\nexport class SymlinkManager {\n  private cache: SymlinkCache | null = null\n  private cacheCount = 0 // Track count to avoid Object.keys() calls\n  private resolvedCache: Map<string, string> = new Map() // Cache resolved paths\n  private dirty = false\n  private handleManager: HandleManager\n  private useSync: boolean\n  private loadPromise: Promise<SymlinkCache> | null = null // Avoid multiple concurrent loads\n  private diskLoaded = false // Track if we've loaded from disk\n\n  constructor(handleManager: HandleManager, useSync: boolean) {\n    this.handleManager = handleManager\n    this.useSync = useSync\n    // Initialize with empty cache - most operations won't need symlinks\n    this.cache = {}\n    this.cacheCount = 0\n  }\n\n  /**\n   * Reset all symlink state (called when root directory is cleared)\n   */\n  reset(): void {\n    this.cache = {}\n    this.cacheCount = 0\n    this.resolvedCache.clear()\n    this.dirty = false\n    this.loadPromise = null\n    this.diskLoaded = false\n  }\n\n  /**\n   * Load symlinks from metadata file\n   * Uses loadPromise to avoid multiple concurrent disk reads\n   */\n  async load(): Promise<SymlinkCache> {\n    // Fast path: if we've already loaded from disk, use cached data\n    if (this.diskLoaded) return this.cache!\n\n    // If there's already a load in progress, wait for it\n    if (this.loadPromise) return this.loadPromise\n\n    // Load from disk\n    this.loadPromise = this.loadFromDisk()\n    const result = await this.loadPromise\n    this.loadPromise = null\n    return result\n  }\n\n  /**\n   * Actually read from disk\n   */\n  private async loadFromDisk(): Promise<SymlinkCache> {\n    try {\n      const { fileHandle } = await this.handleManager.getHandle(SYMLINK_FILE)\n      if (!fileHandle) {\n        // No symlink file exists - keep empty cache\n        this.diskLoaded = true\n        return this.cache!\n      }\n\n      const file = await fileHandle.getFile()\n      const text = await file.text()\n      this.cache = JSON.parse(text)\n      this.cacheCount = Object.keys(this.cache).length\n      this.diskLoaded = true\n    } catch {\n      // Error reading - keep empty cache\n      if (!this.cache) {\n        this.cache = {}\n        this.cacheCount = 0\n      }\n      this.diskLoaded = true\n    }\n\n    return this.cache!\n  }\n\n  /**\n   * Save symlinks to metadata file\n   */\n  async save(): Promise<void> {\n    if (!this.cache) return\n\n    // Use compact JSON (no formatting) for better performance\n    const data = JSON.stringify(this.cache)\n    const { fileHandle } = await this.handleManager.getHandle(SYMLINK_FILE, { create: true })\n\n    if (!fileHandle) return\n\n    const buffer = new TextEncoder().encode(data)\n\n    if (this.useSync) {\n      const access = await fileHandle.createSyncAccessHandle()\n      access.truncate(0)\n      let written = 0\n      while (written < buffer.length) {\n        written += access.write(buffer.subarray(written), { at: written })\n      }\n      access.close()\n    } else {\n      const writable = await fileHandle.createWritable()\n      await writable.write(buffer)\n      await writable.close()\n    }\n\n    this.dirty = false\n  }\n\n  /**\n   * Flush pending changes if dirty\n   */\n  async flush(): Promise<void> {\n    if (this.dirty) {\n      await this.save()\n    }\n  }\n\n  /**\n   * Resolve a path through symlinks\n   * Fast synchronous path when cache is already loaded\n   * Uses resolved cache for O(1) repeated lookups\n   *\n   * OPTIMIZATION: If we haven't loaded from disk yet AND no symlinks have been\n   * created in this session, we skip the disk check entirely. This makes pure\n   * file operations (no symlinks) very fast.\n   */\n  async resolve(path: string, maxDepth = MAX_SYMLINK_DEPTH): Promise<string> {\n    // Ultra-fast path: if no symlinks exist in memory, return immediately\n    // This covers both: (1) fresh session with no symlinks, (2) loaded from disk with no symlinks\n    if (this.cacheCount === 0) {\n      // If we've loaded from disk and it's empty, we're done\n      // If we haven't loaded from disk, assume no symlinks until a symlink op is called\n      return path\n    }\n\n    // We have symlinks in memory - resolve them\n    // Check resolved cache first for instant lookup\n    const cached = this.resolvedCache.get(path)\n    if (cached !== undefined) {\n      return cached\n    }\n    return this.resolveSync(path, this.cache!, maxDepth)\n  }\n\n  /**\n   * Synchronous resolution helper - caches the result\n   */\n  private resolveSync(path: string, symlinks: SymlinkCache, maxDepth: number): string {\n    let currentPath = path\n    let depth = 0\n\n    while (symlinks[currentPath] && depth < maxDepth) {\n      currentPath = symlinks[currentPath]\n      depth++\n    }\n\n    if (depth >= maxDepth) {\n      throw createELOOP(path)\n    }\n\n    // Cache the resolved path if it was actually a symlink\n    if (currentPath !== path) {\n      this.resolvedCache.set(path, currentPath)\n    }\n\n    return currentPath\n  }\n\n  /**\n   * Clear the resolved path cache (called when symlinks change)\n   */\n  private clearResolvedCache(): void {\n    this.resolvedCache.clear()\n  }\n\n  /**\n   * Check if a path is a symlink\n   */\n  async isSymlink(path: string): Promise<boolean> {\n    const symlinks = await this.load()\n    return !!symlinks[path]\n  }\n\n  /**\n   * Get symlink target\n   */\n  async readlink(path: string): Promise<string> {\n    const normalizedPath = normalize(path)\n    const symlinks = await this.load()\n\n    if (!symlinks[normalizedPath]) {\n      throw createEINVAL(path)\n    }\n\n    return symlinks[normalizedPath]\n  }\n\n  /**\n   * Create a symlink\n   */\n  async symlink(target: string, path: string, checkExists: () => Promise<void>): Promise<void> {\n    const normalizedPath = normalize(path)\n    const normalizedTarget = normalize(target)\n\n    const symlinks = await this.load()\n\n    if (symlinks[normalizedPath]) {\n      throw createEEXIST(normalizedPath)\n    }\n\n    await checkExists()\n\n    symlinks[normalizedPath] = normalizedTarget\n    this.cacheCount++\n    this.clearResolvedCache() // Invalidate resolved cache\n    this.dirty = true\n    await this.flush()\n  }\n\n  /**\n   * Create multiple symlinks efficiently\n   */\n  async symlinkBatch(\n    links: SymlinkDefinition[],\n    checkExists: (path: string) => Promise<void>\n  ): Promise<void> {\n    const symlinks = await this.load()\n\n    // Prepare all normalized paths first\n    const normalizedLinks = links.map(({ target, path }) => ({\n      normalizedPath: normalize(path),\n      normalizedTarget: normalize(target)\n    }))\n\n    // Check for existing symlinks in memory (fast)\n    for (const { normalizedPath } of normalizedLinks) {\n      if (symlinks[normalizedPath]) {\n        throw createEEXIST(normalizedPath)\n      }\n    }\n\n    // Check filesystem existence in parallel (I/O bound)\n    await Promise.all(normalizedLinks.map(({ normalizedPath }) => checkExists(normalizedPath)))\n\n    // Add all symlinks at once\n    for (const { normalizedPath, normalizedTarget } of normalizedLinks) {\n      symlinks[normalizedPath] = normalizedTarget\n    }\n\n    this.cacheCount += links.length\n    this.clearResolvedCache() // Invalidate resolved cache\n    this.dirty = true\n    await this.flush()\n  }\n\n  /**\n   * Remove a symlink\n   */\n  async unlink(path: string): Promise<boolean> {\n    const symlinks = await this.load()\n\n    if (symlinks[path]) {\n      delete symlinks[path]\n      this.cacheCount--\n      this.clearResolvedCache() // Invalidate resolved cache\n      this.dirty = true\n      await this.flush()\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * Rename/move a symlink\n   */\n  async rename(oldPath: string, newPath: string): Promise<boolean> {\n    const symlinks = await this.load()\n\n    if (symlinks[oldPath]) {\n      const target = symlinks[oldPath]\n      delete symlinks[oldPath]\n      symlinks[newPath] = target\n      this.clearResolvedCache() // Invalidate resolved cache\n      this.dirty = true\n      await this.flush()\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * Get all symlinks in a directory\n   */\n  async getSymlinksInDir(dirPath: string): Promise<string[]> {\n    const symlinks = await this.load()\n    const result: string[] = []\n\n    for (const symlinkPath of Object.keys(symlinks)) {\n      const parts = symlinkPath.split('/').filter(Boolean)\n      const parentPath = '/' + parts.slice(0, -1).join('/')\n\n      if (parentPath === dirPath || (dirPath === '/' && parts.length === 1)) {\n        result.push(parts[parts.length - 1])\n      }\n    }\n\n    return result\n  }\n\n  /**\n   * Check if path is the symlink metadata file\n   */\n  isMetadataFile(name: string): boolean {\n    return name === SYMLINK_FILE.replace(/^\\/+/, '')\n  }\n}\n","import type { FileHandle, ReadResult, WriteResult, Stats, ReadFileOptions, WriteFileOptions } from './types.js'\n\nexport interface FileHandleContext {\n  readFile(path: string, options?: ReadFileOptions): Promise<string | Uint8Array>\n  writeFile(path: string, data: string | Uint8Array, options?: WriteFileOptions): Promise<void>\n  appendFile(path: string, data: string | Uint8Array, options?: WriteFileOptions): Promise<void>\n  stat(path: string): Promise<Stats>\n  truncate(path: string, len: number): Promise<void>\n}\n\n/**\n * Create a FileHandle-like object for the open() method\n */\nexport function createFileHandle(\n  resolvedPath: string,\n  initialPosition: number,\n  context: FileHandleContext\n): FileHandle {\n  let position = initialPosition\n\n  return {\n    fd: Math.floor(Math.random() * 1000000),\n\n    async read(\n      buffer: Uint8Array,\n      offset = 0,\n      length = buffer.length,\n      pos: number | null = null\n    ): Promise<ReadResult> {\n      const readPos = pos !== null ? pos : position\n      const data = await context.readFile(resolvedPath) as Uint8Array\n      const bytesToRead = Math.min(length, data.length - readPos)\n      buffer.set(data.subarray(readPos, readPos + bytesToRead), offset)\n      if (pos === null) position += bytesToRead\n      return { bytesRead: bytesToRead, buffer }\n    },\n\n    async write(\n      buffer: Uint8Array,\n      offset = 0,\n      length = buffer.length,\n      pos: number | null = null\n    ): Promise<WriteResult> {\n      const writePos = pos !== null ? pos : position\n      let existingData = new Uint8Array(0)\n\n      try {\n        existingData = await context.readFile(resolvedPath) as Uint8Array\n      } catch (e) {\n        if ((e as { code?: string }).code !== 'ENOENT') throw e\n      }\n\n      const dataToWrite = buffer.subarray(offset, offset + length)\n      const newSize = Math.max(existingData.length, writePos + length)\n      const newData = new Uint8Array(newSize)\n      newData.set(existingData, 0)\n      newData.set(dataToWrite, writePos)\n\n      await context.writeFile(resolvedPath, newData)\n      if (pos === null) position += length\n      return { bytesWritten: length, buffer }\n    },\n\n    async close(): Promise<void> {\n      // No-op for OPFS\n    },\n\n    async stat(): Promise<Stats> {\n      return context.stat(resolvedPath)\n    },\n\n    async truncate(len = 0): Promise<void> {\n      return context.truncate(resolvedPath, len)\n    },\n\n    async sync(): Promise<void> {\n      // No-op for OPFS (writes are already persisted)\n    },\n\n    async datasync(): Promise<void> {\n      // No-op for OPFS\n    },\n\n    async readFile(options?: ReadFileOptions): Promise<string | Uint8Array> {\n      return context.readFile(resolvedPath, options)\n    },\n\n    async writeFile(data: string | Uint8Array, options?: WriteFileOptions): Promise<void> {\n      return context.writeFile(resolvedPath, data, options)\n    },\n\n    async appendFile(data: string | Uint8Array, options?: WriteFileOptions): Promise<void> {\n      return context.appendFile(resolvedPath, data, options)\n    },\n\n    [Symbol.asyncDispose]: async function(): Promise<void> {\n      // No-op for OPFS\n    }\n  }\n}\n","import type { ReadStreamOptions, WriteStreamOptions } from './types.js'\n\nexport interface ReadStreamContext {\n  readFile(path: string): Promise<Uint8Array>\n}\n\nexport interface WriteStreamContext {\n  readFile(path: string): Promise<Uint8Array>\n  writeFile(path: string, data: Uint8Array): Promise<void>\n}\n\n/**\n * Create a ReadableStream for reading file contents\n */\nexport function createReadStream(\n  path: string,\n  options: ReadStreamOptions,\n  context: ReadStreamContext\n): ReadableStream<Uint8Array> {\n  const { start = 0, end = Infinity, highWaterMark = 64 * 1024 } = options\n  let position = start\n  let closed = false\n  let cachedData: Uint8Array | null = null\n\n  return new ReadableStream({\n    async pull(controller) {\n      if (closed) {\n        controller.close()\n        return\n      }\n\n      try {\n        // Cache file data on first read - avoid re-reading on every pull\n        if (cachedData === null) {\n          cachedData = await context.readFile(path)\n        }\n\n        const endPos = Math.min(end, cachedData.length)\n        const chunk = cachedData.subarray(position, Math.min(position + highWaterMark, endPos))\n\n        if (chunk.length === 0 || position >= endPos) {\n          controller.close()\n          closed = true\n          cachedData = null // Release memory\n          return\n        }\n\n        position += chunk.length\n        controller.enqueue(chunk)\n      } catch (err) {\n        controller.error(err)\n      }\n    },\n    cancel() {\n      closed = true\n      cachedData = null // Release memory\n    }\n  })\n}\n\n/**\n * Create a WritableStream for writing file contents\n */\nexport function createWriteStream(\n  path: string,\n  options: WriteStreamOptions,\n  context: WriteStreamContext\n): WritableStream<Uint8Array> {\n  const { flags = 'w', start = 0 } = options\n  const chunks: Array<{ data: Uint8Array; position: number }> = []\n  let position = start\n\n  return new WritableStream({\n    async write(chunk) {\n      chunks.push({ data: chunk, position })\n      position += chunk.length\n    },\n\n    async close() {\n      // Combine all chunks\n      let existingData = new Uint8Array(0)\n\n      if (!flags.includes('w')) {\n        try {\n          existingData = await context.readFile(path)\n        } catch (e) {\n          if ((e as { code?: string }).code !== 'ENOENT') throw e\n        }\n      }\n\n      let maxSize = existingData.length\n      for (const { data, position } of chunks) {\n        maxSize = Math.max(maxSize, position + data.length)\n      }\n\n      const finalData = new Uint8Array(maxSize)\n\n      if (!flags.includes('w')) {\n        finalData.set(existingData, 0)\n      }\n\n      for (const { data, position } of chunks) {\n        finalData.set(data, position)\n      }\n\n      await context.writeFile(path, finalData)\n    }\n  })\n}\n","import type {\n  OPFSOptions,\n  ReadFileOptions,\n  WriteFileOptions,\n  BatchWriteEntry,\n  BatchReadResult,\n  ReaddirOptions,\n  Dirent,\n  Stats,\n  StatFs,\n  RmOptions,\n  CpOptions,\n  WatchOptions,\n  FSWatcher,\n  ReadStreamOptions,\n  WriteStreamOptions,\n  FileHandle,\n  Dir,\n  DiskUsage,\n  SymlinkDefinition,\n  WatchCallback,\n  WatchRegistration\n} from './types.js'\nimport { constants, flagsToString } from './constants.js'\nimport { createENOENT, createEEXIST, createEACCES, createEISDIR, wrapError } from './errors.js'\nimport { normalize, dirname, basename, join, isRoot, segments } from './path-utils.js'\nimport { HandleManager } from './handle-manager.js'\nimport { SymlinkManager } from './symlink-manager.js'\nimport { createFileHandle } from './file-handle.js'\nimport { createReadStream, createWriteStream } from './streams.js'\nimport { OPFSHybrid, type OPFSHybridOptions, type Backend } from './opfs-hybrid.js'\n\nexport { constants }\nexport * from './types.js'\nexport { OPFSHybrid, type OPFSHybridOptions, type Backend }\n\n/** Extended options that include hybrid mode support */\nexport interface OPFSExtendedOptions extends OPFSOptions {\n  /** Worker script URL - when provided, enables hybrid mode (reads on main, writes on worker) */\n  workerUrl?: URL | string\n  /** Override read backend when using hybrid mode (default: 'main') */\n  read?: Backend\n  /** Override write backend when using hybrid mode (default: 'worker') */\n  write?: Backend\n}\n\n/**\n * OPFS-based filesystem implementation compatible with Node.js fs/promises API\n *\n * When `workerUrl` is provided, automatically uses hybrid mode for optimal performance:\n * - Reads on main thread (no message passing overhead)\n * - Writes on worker (sync access handles are faster)\n */\nexport default class OPFS {\n  private useSync: boolean\n  private verbose: boolean\n  private handleManager: HandleManager\n  private symlinkManager: SymlinkManager\n  private watchCallbacks: Map<symbol, WatchRegistration> = new Map()\n  private tmpCounter = 0\n\n  /** Hybrid instance when workerUrl is provided */\n  private hybrid: OPFSHybrid | null = null\n\n  /** File system constants */\n  public readonly constants = constants\n\n  constructor(options: OPFSExtendedOptions = {}) {\n    const { useSync = true, verbose = false, workerUrl, read, write } = options\n    this.verbose = verbose\n\n    // If workerUrl is provided, use hybrid mode\n    if (workerUrl) {\n      this.hybrid = new OPFSHybrid({\n        workerUrl,\n        read: read ?? 'main',\n        write: write ?? 'worker',\n        verbose\n      })\n      // These won't be used in hybrid mode but need to be initialized\n      this.useSync = false\n      this.handleManager = new HandleManager()\n      this.symlinkManager = new SymlinkManager(this.handleManager, false)\n    } else {\n      this.useSync = useSync && typeof FileSystemFileHandle !== 'undefined' &&\n        'createSyncAccessHandle' in FileSystemFileHandle.prototype\n      this.handleManager = new HandleManager()\n      this.symlinkManager = new SymlinkManager(this.handleManager, this.useSync)\n    }\n  }\n\n  /**\n   * Wait for the filesystem to be ready (only needed for hybrid mode)\n   */\n  async ready(): Promise<void> {\n    if (this.hybrid) {\n      await this.hybrid.ready()\n    }\n  }\n\n  /**\n   * Terminate any background workers (only needed for hybrid mode)\n   */\n  terminate(): void {\n    if (this.hybrid) {\n      this.hybrid.terminate()\n    }\n  }\n\n  private log(method: string, ...args: unknown[]): void {\n    if (this.verbose) {\n      console.log(`[OPFS] ${method}:`, ...args)\n    }\n  }\n\n  private logError(method: string, err: unknown): void {\n    if (this.verbose) {\n      console.error(`[OPFS] ${method} error:`, err)\n    }\n  }\n\n  /**\n   * Execute tasks with limited concurrency to avoid overwhelming the system\n   * @param items - Array of items to process\n   * @param maxConcurrent - Maximum number of concurrent operations (default: 10)\n   * @param taskFn - Function to execute for each item\n   */\n  private async limitConcurrency<T>(\n    items: T[],\n    maxConcurrent: number,\n    taskFn: (item: T) => Promise<void>\n  ): Promise<void> {\n    if (items.length === 0) return\n\n    // For very small batches, run sequentially (minimal overhead)\n    if (items.length <= 2) {\n      for (const item of items) {\n        await taskFn(item)\n      }\n      return\n    }\n\n    // For medium batches up to maxConcurrent, use Promise.all for true parallelism\n    // This is optimal for browser where I/O can truly run in parallel\n    if (items.length <= maxConcurrent) {\n      await Promise.all(items.map(taskFn))\n      return\n    }\n\n    // For large batches, use worker pool pattern to limit concurrency\n    const queue = [...items]\n    const workers = Array.from({ length: maxConcurrent }).map(async () => {\n      while (queue.length) {\n        const item = queue.shift()\n        if (item !== undefined) await taskFn(item)\n      }\n    })\n    await Promise.all(workers)\n  }\n\n  /**\n   * Read file contents\n   */\n  async readFile(path: string, options: ReadFileOptions = {}): Promise<string | Uint8Array> {\n    if (this.hybrid) {\n      return this.hybrid.readFile(path, options)\n    }\n\n    this.log('readFile', path, options)\n    try {\n      const normalizedPath = normalize(path)\n      const resolvedPath = await this.symlinkManager.resolve(normalizedPath)\n\n      // Use pooled file handle for faster repeated access\n      const fileHandle = await this.handleManager.getPooledFileHandle(resolvedPath)\n\n      if (!fileHandle) {\n        throw createENOENT(path)\n      }\n\n      let buffer: Uint8Array\n\n      if (this.useSync) {\n        const access = await fileHandle.createSyncAccessHandle()\n        const size = access.getSize()\n        buffer = new Uint8Array(size)\n        access.read(buffer)\n        access.close()\n      } else {\n        const file = await fileHandle.getFile()\n        buffer = new Uint8Array(await file.arrayBuffer())\n      }\n\n      return options.encoding\n        ? new TextDecoder(options.encoding).decode(buffer)\n        : buffer\n    } catch (err) {\n      this.logError('readFile', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Read multiple files efficiently in a batch operation\n   * More performant than multiple readFile calls for bulk operations\n   * Returns results in the same order as input paths\n   */\n  async readFileBatch(paths: string[]): Promise<BatchReadResult[]> {\n    if (this.hybrid) {\n      return this.hybrid.readFileBatch(paths)\n    }\n\n    this.log('readFileBatch', `${paths.length} files`)\n    if (paths.length === 0) return []\n\n    try {\n      // Resolve all symlinks in parallel first (I/O bound)\n      const resolvedPaths = await Promise.all(\n        paths.map(async (path, index) => {\n          const normalizedPath = normalize(path)\n          const resolvedPath = await this.symlinkManager.resolve(normalizedPath)\n          return { index, resolvedPath }\n        })\n      )\n\n      // Group by parent directory (now synchronous)\n      const byParent = new Map<string, Array<{ index: number; name: string; resolvedPath: string }>>()\n\n      for (const { index, resolvedPath } of resolvedPaths) {\n        const parentPath = dirname(resolvedPath)\n        const name = basename(resolvedPath)\n\n        if (!byParent.has(parentPath)) {\n          byParent.set(parentPath, [])\n        }\n        byParent.get(parentPath)!.push({ index, name, resolvedPath })\n      }\n\n      // Pre-allocate results array\n      const results: BatchReadResult[] = new Array(paths.length)\n\n      // Process all directory groups in parallel\n      await Promise.all(\n        Array.from(byParent.entries()).map(async ([parentPath, files]) => {\n          let parentHandle: FileSystemDirectoryHandle\n          try {\n            parentHandle = await this.handleManager.getDirectoryHandle(parentPath)\n          } catch {\n            // Parent doesn't exist - mark all files in this group as not found\n            for (const { index } of files) {\n              results[index] = { path: paths[index], data: null, error: createENOENT(paths[index]) }\n            }\n            return\n          }\n\n          // Read all files in this directory in parallel\n          await Promise.all(\n            files.map(async ({ index, name }) => {\n              try {\n                const fileHandle = await parentHandle.getFileHandle(name)\n                let buffer: Uint8Array\n\n                if (this.useSync) {\n                  const access = await fileHandle.createSyncAccessHandle()\n                  const size = access.getSize()\n                  buffer = new Uint8Array(size)\n                  access.read(buffer)\n                  access.close()\n                } else {\n                  const file = await fileHandle.getFile()\n                  buffer = new Uint8Array(await file.arrayBuffer())\n                }\n\n                results[index] = { path: paths[index], data: buffer }\n              } catch (err) {\n                results[index] = { path: paths[index], data: null, error: err as Error }\n              }\n            })\n          )\n        })\n      )\n\n      return results\n    } catch (err) {\n      this.logError('readFileBatch', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Write data to a file\n   */\n  async writeFile(path: string, data: string | Uint8Array, options: WriteFileOptions = {}): Promise<void> {\n    if (this.hybrid) {\n      return this.hybrid.writeFile(path, data, options)\n    }\n\n    this.log('writeFile', path)\n    try {\n      const normalizedPath = normalize(path)\n      const resolvedPath = await this.symlinkManager.resolve(normalizedPath)\n\n      const { fileHandle } = await this.handleManager.getHandle(resolvedPath, { create: true })\n      const buffer = typeof data === 'string' ? new TextEncoder().encode(data) : data\n\n      if (this.useSync) {\n        const access = await fileHandle!.createSyncAccessHandle()\n        // Set exact size (more efficient than truncate(0) + write)\n        access.truncate(buffer.length)\n        access.write(buffer, { at: 0 })\n        access.close()\n      } else {\n        const writable = await fileHandle!.createWritable()\n        await writable.write(buffer)\n        await writable.close()\n      }\n    } catch (err) {\n      this.logError('writeFile', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Write multiple files efficiently in a batch operation\n   * More performant than multiple writeFile calls for bulk operations\n   */\n  async writeFileBatch(entries: BatchWriteEntry[]): Promise<void> {\n    if (this.hybrid) {\n      return this.hybrid.writeFileBatch(entries)\n    }\n\n    this.log('writeFileBatch', `${entries.length} files`)\n    if (entries.length === 0) return\n\n    try {\n      // Reuse encoder for all string conversions\n      const encoder = new TextEncoder()\n\n      // Resolve all symlinks and convert data in parallel (I/O bound)\n      const resolvedEntries = await Promise.all(\n        entries.map(async ({ path, data }) => {\n          const normalizedPath = normalize(path)\n          const resolvedPath = await this.symlinkManager.resolve(normalizedPath)\n          return {\n            resolvedPath,\n            buffer: typeof data === 'string' ? encoder.encode(data) : data\n          }\n        })\n      )\n\n      // Group entries by parent directory (now synchronous)\n      const byParent = new Map<string, Array<{ name: string; buffer: Uint8Array }>>()\n\n      for (const { resolvedPath, buffer } of resolvedEntries) {\n        const parentPath = dirname(resolvedPath)\n        const name = basename(resolvedPath)\n\n        if (!byParent.has(parentPath)) {\n          byParent.set(parentPath, [])\n        }\n        byParent.get(parentPath)!.push({ name, buffer })\n      }\n\n      // Pre-create all directories and get handles in parallel\n      const parentPaths = Array.from(byParent.keys())\n      await Promise.all(parentPaths.map((parentPath) => this.handleManager.mkdir(parentPath)))\n      const parentHandles = await Promise.all(\n        parentPaths.map((parentPath) => this.handleManager.getDirectoryHandle(parentPath))\n      )\n      const handleMap = new Map(parentPaths.map((path, i) => [path, parentHandles[i]]))\n\n      // Write all files across all directories in a single parallel batch\n      await Promise.all(\n        Array.from(byParent.entries()).flatMap(([parentPath, files]) => {\n          const parentHandle = handleMap.get(parentPath)!\n          return files.map(async ({ name, buffer }) => {\n            const fileHandle = await parentHandle.getFileHandle(name, { create: true })\n\n            if (this.useSync) {\n              const access = await fileHandle.createSyncAccessHandle()\n              // Set exact size (more efficient than truncate(0) + write)\n              access.truncate(buffer.length)\n              access.write(buffer, { at: 0 })\n              access.close()\n            } else {\n              const writable = await fileHandle.createWritable()\n              await writable.write(buffer)\n              await writable.close()\n            }\n          })\n        })\n      )\n    } catch (err) {\n      this.logError('writeFileBatch', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Create a directory\n   */\n  async mkdir(path: string): Promise<void> {\n    if (this.hybrid) {\n      return this.hybrid.mkdir(path)\n    }\n\n    this.log('mkdir', path)\n    try {\n      await this.handleManager.mkdir(path)\n    } catch (err) {\n      this.logError('mkdir', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Remove a directory\n   */\n  async rmdir(path: string): Promise<void> {\n    if (this.hybrid) {\n      return this.hybrid.rmdir(path)\n    }\n\n    this.log('rmdir', path)\n    try {\n      const normalizedPath = normalize(path)\n      this.handleManager.clearCache(normalizedPath)\n\n      if (isRoot(normalizedPath)) {\n        const root = await this.handleManager.getRoot()\n        const entries: string[] = []\n        for await (const [name] of root.entries()) {\n          entries.push(name)\n        }\n        await this.limitConcurrency(entries, 10, (name) =>\n          root.removeEntry(name, { recursive: true })\n        )\n        // Reset symlink manager state since all files including metadata are gone\n        this.symlinkManager.reset()\n        return\n      }\n\n      const pathSegments = segments(normalizedPath)\n      const name = pathSegments.pop()!\n      let dir = await this.handleManager.getRoot()\n\n      for (const part of pathSegments) {\n        dir = await dir.getDirectoryHandle(part)\n      }\n\n      try {\n        await dir.removeEntry(name, { recursive: true })\n      } catch {\n        throw createENOENT(path)\n      }\n    } catch (err) {\n      this.logError('rmdir', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Remove a file or symlink\n   */\n  async unlink(path: string): Promise<void> {\n    if (this.hybrid) {\n      return this.hybrid.unlink(path)\n    }\n\n    this.log('unlink', path)\n    try {\n      const normalizedPath = normalize(path)\n      this.handleManager.clearCache(normalizedPath)\n\n      const isSymlink = await this.symlinkManager.isSymlink(normalizedPath)\n      if (isSymlink) {\n        await this.symlinkManager.unlink(normalizedPath)\n        return\n      }\n\n      const { dir, name, fileHandle } = await this.handleManager.getHandle(normalizedPath)\n      if (!fileHandle) throw createENOENT(path)\n\n      try {\n        await dir!.removeEntry(name!)\n      } catch {\n        throw createENOENT(path)\n      }\n    } catch (err) {\n      this.logError('unlink', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Read directory contents\n   */\n  async readdir(path: string, options?: ReaddirOptions): Promise<string[] | Dirent[]> {\n    if (this.hybrid) {\n      return this.hybrid.readdir(path, options)\n    }\n\n    this.log('readdir', path, options)\n    try {\n      const normalizedPath = normalize(path)\n      const resolvedPath = await this.symlinkManager.resolve(normalizedPath)\n\n      const dir = await this.handleManager.getDirectoryHandle(resolvedPath)\n      const withFileTypes = options?.withFileTypes === true\n\n      // Pre-fetch symlinks only once - skip if no symlinks exist (common case)\n      const symlinksInDir = await this.symlinkManager.getSymlinksInDir(resolvedPath)\n      const hasSymlinks = symlinksInDir.length > 0\n      const symlinkSet = hasSymlinks ? new Set(symlinksInDir) : null\n\n      // Collect entries from OPFS directory\n      const entryNames = new Set<string>()\n      const entries: (string | Dirent)[] = []\n\n      for await (const [name, handle] of dir.entries()) {\n        if (this.symlinkManager.isMetadataFile(name)) continue\n\n        entryNames.add(name)\n\n        if (withFileTypes) {\n          // Only check symlink if there are symlinks\n          const isSymlink = hasSymlinks && symlinkSet!.has(name)\n          entries.push({\n            name,\n            isFile: () => !isSymlink && handle.kind === 'file',\n            isDirectory: () => !isSymlink && handle.kind === 'directory',\n            isSymbolicLink: () => isSymlink\n          })\n        } else {\n          entries.push(name)\n        }\n      }\n\n      // Add symlinks that don't have corresponding OPFS entries (only if there are symlinks)\n      if (hasSymlinks) {\n        for (const name of symlinksInDir) {\n          if (!entryNames.has(name)) {\n            if (withFileTypes) {\n              entries.push({\n                name,\n                isFile: () => false,\n                isDirectory: () => false,\n                isSymbolicLink: () => true\n              })\n            } else {\n              entries.push(name)\n            }\n          }\n        }\n      }\n\n      return entries as string[] | Dirent[]\n    } catch (err) {\n      this.logError('readdir', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Get file/directory statistics (follows symlinks)\n   */\n  async stat(path: string): Promise<Stats> {\n    if (this.hybrid) {\n      return this.hybrid.stat(path)\n    }\n\n    this.log('stat', path)\n    try {\n      const normalizedPath = normalize(path)\n      const resolvedPath = await this.symlinkManager.resolve(normalizedPath)\n      const defaultDate = new Date(0)\n\n      if (isRoot(resolvedPath)) {\n        return {\n          type: 'dir',\n          size: 0,\n          mode: 0o040755,\n          ctime: defaultDate,\n          ctimeMs: 0,\n          mtime: defaultDate,\n          mtimeMs: 0,\n          isFile: () => false,\n          isDirectory: () => true,\n          isSymbolicLink: () => false\n        }\n      }\n\n      const pathSegments = segments(resolvedPath)\n      const name = pathSegments.pop()!\n      let dir = await this.handleManager.getRoot()\n\n      for (const part of pathSegments) {\n        try {\n          dir = await dir.getDirectoryHandle(part)\n        } catch {\n          throw createENOENT(path)\n        }\n      }\n\n      // Check both file and directory in parallel for best performance\n      const [fileResult, dirResult] = await Promise.allSettled([\n        dir.getFileHandle(name),\n        dir.getDirectoryHandle(name)\n      ])\n\n      if (fileResult.status === 'fulfilled') {\n        const fileHandle = fileResult.value\n        const file = await fileHandle.getFile()\n        const mtime = file.lastModified ? new Date(file.lastModified) : defaultDate\n\n        return {\n          type: 'file',\n          size: file.size,\n          mode: 0o100644,\n          ctime: mtime,\n          ctimeMs: mtime.getTime(),\n          mtime,\n          mtimeMs: mtime.getTime(),\n          isFile: () => true,\n          isDirectory: () => false,\n          isSymbolicLink: () => false\n        }\n      }\n\n      if (dirResult.status === 'fulfilled') {\n        return {\n          type: 'dir',\n          size: 0,\n          mode: 0o040755,\n          ctime: defaultDate,\n          ctimeMs: 0,\n          mtime: defaultDate,\n          mtimeMs: 0,\n          isFile: () => false,\n          isDirectory: () => true,\n          isSymbolicLink: () => false\n        }\n      }\n\n      throw createENOENT(path)\n    } catch (err) {\n      this.logError('stat', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Get file/directory statistics (does not follow symlinks)\n   */\n  async lstat(path: string): Promise<Stats> {\n    if (this.hybrid) {\n      return this.hybrid.lstat(path)\n    }\n\n    this.log('lstat', path)\n    try {\n      const normalizedPath = normalize(path)\n      const isSymlink = await this.symlinkManager.isSymlink(normalizedPath)\n\n      if (isSymlink) {\n        const target = await this.symlinkManager.readlink(normalizedPath)\n        return {\n          type: 'symlink',\n          target,\n          size: target.length,\n          mode: 0o120777,\n          ctime: new Date(0),\n          ctimeMs: 0,\n          mtime: new Date(0),\n          mtimeMs: 0,\n          isFile: () => false,\n          isDirectory: () => false,\n          isSymbolicLink: () => true\n        }\n      }\n\n      return this.stat(path)\n    } catch (err) {\n      this.logError('lstat', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Rename a file or directory\n   */\n  async rename(oldPath: string, newPath: string): Promise<void> {\n    if (this.hybrid) {\n      return this.hybrid.rename(oldPath, newPath)\n    }\n\n    this.log('rename', oldPath, newPath)\n    try {\n      const normalizedOld = normalize(oldPath)\n      const normalizedNew = normalize(newPath)\n\n      this.handleManager.clearCache(normalizedOld)\n      this.handleManager.clearCache(normalizedNew)\n\n      // Handle symlink rename\n      const renamed = await this.symlinkManager.rename(normalizedOld, normalizedNew)\n      if (renamed) return\n\n      const stat = await this.stat(normalizedOld)\n\n      if (stat.isFile()) {\n        // Run readFile and ensureParentDir in parallel (no dependency)\n        const [data] = await Promise.all([\n          this.readFile(normalizedOld),\n          this.handleManager.ensureParentDir(normalizedNew)\n        ])\n        await this.writeFile(normalizedNew, data as Uint8Array)\n        await this.unlink(normalizedOld)\n      } else if (stat.isDirectory()) {\n        await this.mkdir(normalizedNew)\n        const entries = await this.readdir(normalizedOld) as string[]\n        // Use concurrency limiter to avoid Promise overhead for small batches\n        await this.limitConcurrency(entries, 10, entry =>\n          this.rename(`${normalizedOld}/${entry}`, `${normalizedNew}/${entry}`)\n        )\n        await this.rmdir(normalizedOld)\n      }\n    } catch (err) {\n      this.logError('rename', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Create a symbolic link\n   */\n  async symlink(target: string, path: string): Promise<void> {\n    if (this.hybrid) {\n      return this.hybrid.symlink(target, path)\n    }\n\n    this.log('symlink', target, path)\n    try {\n      const normalizedPath = normalize(path)\n      this.handleManager.clearCache(normalizedPath)\n\n      // Fast existence check - just try to get handle, much faster than full stat()\n      await this.symlinkManager.symlink(target, path, async () => {\n        const { fileHandle, dirHandle } = await this.handleManager.getHandle(normalizedPath)\n        if (fileHandle || dirHandle) {\n          throw createEEXIST(path)\n        }\n      })\n    } catch (err) {\n      this.logError('symlink', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Read symlink target\n   */\n  async readlink(path: string): Promise<string> {\n    if (this.hybrid) {\n      return this.hybrid.readlink(path)\n    }\n\n    this.log('readlink', path)\n    try {\n      return await this.symlinkManager.readlink(path)\n    } catch (err) {\n      this.logError('readlink', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Create multiple symlinks efficiently\n   */\n  async symlinkBatch(links: SymlinkDefinition[]): Promise<void> {\n    if (this.hybrid) {\n      return this.hybrid.symlinkBatch(links)\n    }\n\n    this.log('symlinkBatch', links.length, 'links')\n    try {\n      // Clear cache once at the start for all paths\n      for (const { path } of links) {\n        this.handleManager.clearCache(normalize(path))\n      }\n\n      // Fast existence check - if parent doesn't exist, symlink path is available\n      await this.symlinkManager.symlinkBatch(links, async (normalizedPath) => {\n        try {\n          const { fileHandle, dirHandle } = await this.handleManager.getHandle(normalizedPath)\n          if (fileHandle || dirHandle) {\n            throw createEEXIST(normalizedPath)\n          }\n        } catch (err) {\n          // If ENOENT (parent doesn't exist), the path is available for symlink\n          if ((err as { code?: string }).code === 'ENOENT') return\n          throw err\n        }\n      })\n    } catch (err) {\n      this.logError('symlinkBatch', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Check file accessibility\n   */\n  async access(path: string, mode = constants.F_OK): Promise<void> {\n    if (this.hybrid) {\n      return this.hybrid.access(path, mode)\n    }\n\n    this.log('access', path, mode)\n    try {\n      const normalizedPath = normalize(path)\n      await this.stat(normalizedPath)\n      // OPFS doesn't have permissions, existence check is enough\n    } catch (err) {\n      this.logError('access', err)\n      throw createEACCES(path)\n    }\n  }\n\n  /**\n   * Append data to a file\n   */\n  async appendFile(path: string, data: string | Uint8Array, options: WriteFileOptions = {}): Promise<void> {\n    if (this.hybrid) {\n      return this.hybrid.appendFile(path, data, options)\n    }\n\n    this.log('appendFile', path)\n    try {\n      const normalizedPath = normalize(path)\n      const resolvedPath = await this.symlinkManager.resolve(normalizedPath)\n\n      let existingData: Uint8Array = new Uint8Array(0)\n      try {\n        const result = await this.readFile(resolvedPath)\n        existingData = result instanceof Uint8Array ? result : new TextEncoder().encode(result)\n      } catch (err) {\n        if ((err as { code?: string }).code !== 'ENOENT') throw err\n      }\n\n      const newData = typeof data === 'string'\n        ? new TextEncoder().encode(data)\n        : data\n\n      const combined = new Uint8Array(existingData.length + newData.length)\n      combined.set(existingData, 0)\n      combined.set(newData, existingData.length)\n\n      await this.writeFile(resolvedPath, combined, options)\n    } catch (err) {\n      this.logError('appendFile', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Copy a file\n   */\n  async copyFile(src: string, dest: string, mode = 0): Promise<void> {\n    if (this.hybrid) {\n      return this.hybrid.copyFile(src, dest, mode)\n    }\n\n    this.log('copyFile', src, dest, mode)\n    try {\n      const normalizedSrc = normalize(src)\n      const normalizedDest = normalize(dest)\n      const resolvedSrc = await this.symlinkManager.resolve(normalizedSrc)\n\n      // Check COPYFILE_EXCL flag\n      if (mode & constants.COPYFILE_EXCL) {\n        try {\n          await this.stat(normalizedDest)\n          throw createEEXIST(dest)\n        } catch (err) {\n          if ((err as { code?: string }).code !== 'ENOENT') throw err\n        }\n      }\n\n      // Run readFile and ensureParentDir in parallel (no dependency)\n      const [data] = await Promise.all([\n        this.readFile(resolvedSrc),\n        this.handleManager.ensureParentDir(normalizedDest)\n      ])\n      await this.writeFile(normalizedDest, data as Uint8Array)\n    } catch (err) {\n      this.logError('copyFile', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Copy files/directories recursively\n   */\n  async cp(src: string, dest: string, options: CpOptions = {}): Promise<void> {\n    if (this.hybrid) {\n      return this.hybrid.cp(src, dest, options)\n    }\n\n    this.log('cp', src, dest, options)\n    try {\n      const normalizedSrc = normalize(src)\n      const normalizedDest = normalize(dest)\n      const { recursive = false, force = false, errorOnExist = false } = options\n\n      const srcStat = await this.stat(normalizedSrc)\n\n      if (srcStat.isDirectory()) {\n        if (!recursive) {\n          throw createEISDIR(src)\n        }\n\n        let destExists = false\n        try {\n          await this.stat(normalizedDest)\n          destExists = true\n          if (errorOnExist && !force) {\n            throw createEEXIST(dest)\n          }\n        } catch (err) {\n          if ((err as { code?: string }).code !== 'ENOENT') throw err\n        }\n\n        if (!destExists) {\n          await this.mkdir(normalizedDest)\n        }\n\n        const entries = await this.readdir(normalizedSrc) as string[]\n        // Use concurrency limiter to avoid Promise overhead for small batches\n        await this.limitConcurrency(entries, 10, entry =>\n          this.cp(`${normalizedSrc}/${entry}`, `${normalizedDest}/${entry}`, options)\n        )\n      } else {\n        if (errorOnExist) {\n          try {\n            await this.stat(normalizedDest)\n            throw createEEXIST(dest)\n          } catch (err) {\n            if ((err as { code?: string }).code !== 'ENOENT') throw err\n          }\n        }\n        await this.copyFile(normalizedSrc, normalizedDest)\n      }\n    } catch (err) {\n      this.logError('cp', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Check if path exists\n   */\n  async exists(path: string): Promise<boolean> {\n    if (this.hybrid) {\n      return this.hybrid.exists(path)\n    }\n\n    this.log('exists', path)\n    try {\n      await this.stat(normalize(path))\n      return true\n    } catch {\n      return false\n    }\n  }\n\n  /**\n   * Resolve symlinks to get real path\n   */\n  async realpath(path: string): Promise<string> {\n    if (this.hybrid) {\n      return this.hybrid.realpath(path)\n    }\n\n    this.log('realpath', path)\n    const normalizedPath = normalize(path)\n    return this.symlinkManager.resolve(normalizedPath)\n  }\n\n  /**\n   * Remove files and directories\n   */\n  async rm(path: string, options: RmOptions = {}): Promise<void> {\n    if (this.hybrid) {\n      return this.hybrid.rm(path, options)\n    }\n\n    this.log('rm', path, options)\n    try {\n      const normalizedPath = normalize(path)\n      const { recursive = false, force = false } = options\n\n      try {\n        const stat = await this.lstat(normalizedPath)\n\n        if (stat.isSymbolicLink()) {\n          await this.unlink(normalizedPath)\n        } else if (stat.isDirectory()) {\n          if (!recursive) {\n            throw createEISDIR(path)\n          }\n          await this.rmdir(normalizedPath)\n        } else {\n          await this.unlink(normalizedPath)\n        }\n      } catch (err) {\n        if ((err as { code?: string }).code === 'ENOENT' && force) {\n          return\n        }\n        throw err\n      }\n    } catch (err) {\n      this.logError('rm', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Truncate file to specified length\n   */\n  async truncate(path: string, len = 0): Promise<void> {\n    if (this.hybrid) {\n      return this.hybrid.truncate(path, len)\n    }\n\n    this.log('truncate', path, len)\n    try {\n      const normalizedPath = normalize(path)\n      const resolvedPath = await this.symlinkManager.resolve(normalizedPath)\n      this.handleManager.clearCache(resolvedPath)\n\n      const { fileHandle } = await this.handleManager.getHandle(resolvedPath)\n      if (!fileHandle) throw createENOENT(path)\n\n      if (this.useSync) {\n        const access = await fileHandle.createSyncAccessHandle()\n        access.truncate(len)\n        access.close()\n      } else {\n        const file = await fileHandle.getFile()\n        const data = new Uint8Array(await file.arrayBuffer())\n\n        // Create a new array with the truncated/padded size\n        const finalData = new Uint8Array(len)\n        // Copy up to len bytes from original data using set() for performance\n        const copyLen = Math.min(len, data.length)\n        if (copyLen > 0) {\n          finalData.set(data.subarray(0, copyLen), 0)\n        }\n        // Remaining bytes (if any) are already zero from Uint8Array initialization\n\n        const writable = await fileHandle.createWritable()\n        await writable.write(finalData)\n        await writable.close()\n      }\n    } catch (err) {\n      this.logError('truncate', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Create a unique temporary directory\n   */\n  async mkdtemp(prefix: string): Promise<string> {\n    if (this.hybrid) {\n      return this.hybrid.mkdtemp(prefix)\n    }\n\n    this.log('mkdtemp', prefix)\n    try {\n      const normalizedPrefix = normalize(prefix)\n      const suffix = `${Date.now()}-${++this.tmpCounter}-${Math.random().toString(36).slice(2, 8)}`\n      const path = `${normalizedPrefix}${suffix}`\n      await this.mkdir(path)\n      return path\n    } catch (err) {\n      this.logError('mkdtemp', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Change file mode (no-op for OPFS compatibility)\n   */\n  async chmod(path: string, mode: number): Promise<void> {\n    if (this.hybrid) {\n      return this.hybrid.chmod(path, mode)\n    }\n\n    this.log('chmod', path, mode)\n    await this.stat(normalize(path))\n    // OPFS doesn't support file modes\n  }\n\n  /**\n   * Change file owner (no-op for OPFS compatibility)\n   */\n  async chown(path: string, uid: number, gid: number): Promise<void> {\n    if (this.hybrid) {\n      return this.hybrid.chown(path, uid, gid)\n    }\n\n    this.log('chown', path, uid, gid)\n    await this.stat(normalize(path))\n    // OPFS doesn't support file ownership\n  }\n\n  /**\n   * Update file timestamps (no-op for OPFS compatibility)\n   */\n  async utimes(path: string, atime: Date | number, mtime: Date | number): Promise<void> {\n    if (this.hybrid) {\n      return this.hybrid.utimes(path, atime, mtime)\n    }\n\n    this.log('utimes', path, atime, mtime)\n    await this.stat(normalize(path))\n    // OPFS doesn't support setting timestamps\n  }\n\n  /**\n   * Update symlink timestamps (no-op)\n   */\n  async lutimes(path: string, atime: Date | number, mtime: Date | number): Promise<void> {\n    if (this.hybrid) {\n      return this.hybrid.lutimes(path, atime, mtime)\n    }\n\n    this.log('lutimes', path, atime, mtime)\n    await this.lstat(normalize(path))\n    // OPFS doesn't support setting timestamps\n  }\n\n  /**\n   * Open file and return FileHandle\n   */\n  async open(path: string, flags: string | number = 'r', mode = 0o666): Promise<FileHandle> {\n    this.log('open', path, flags, mode)\n    try {\n      const normalizedPath = normalize(path)\n      const flagStr = flagsToString(flags)\n      const shouldCreate = flagStr.includes('w') || flagStr.includes('a') || flagStr.includes('+')\n      const shouldTruncate = flagStr.includes('w')\n      const shouldAppend = flagStr.includes('a')\n\n      if (shouldCreate) {\n        await this.handleManager.ensureParentDir(normalizedPath)\n      }\n\n      const resolvedPath = await this.symlinkManager.resolve(normalizedPath)\n      const { fileHandle } = await this.handleManager.getHandle(resolvedPath, { create: shouldCreate })\n\n      if (!fileHandle && !shouldCreate) {\n        throw createENOENT(path)\n      }\n\n      if (shouldTruncate && fileHandle) {\n        await this.truncate(resolvedPath, 0)\n      }\n\n      const initialPosition = shouldAppend ? (await this.stat(resolvedPath)).size : 0\n\n      return createFileHandle(resolvedPath, initialPosition, {\n        readFile: (p, o) => this.readFile(p, o),\n        writeFile: (p, d) => this.writeFile(p, d),\n        stat: (p) => this.stat(p),\n        truncate: (p, l) => this.truncate(p, l),\n        appendFile: (p, d, o) => this.appendFile(p, d, o)\n      })\n    } catch (err) {\n      this.logError('open', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Open directory for iteration\n   */\n  async opendir(path: string): Promise<Dir> {\n    this.log('opendir', path)\n    try {\n      const normalizedPath = normalize(path)\n      const entries = await this.readdir(normalizedPath, { withFileTypes: true }) as Dirent[]\n      let index = 0\n\n      return {\n        path: normalizedPath,\n\n        async read(): Promise<Dirent | null> {\n          if (index >= entries.length) return null\n          return entries[index++]\n        },\n\n        async close(): Promise<void> {\n          index = entries.length\n        },\n\n        async *[Symbol.asyncIterator](): AsyncIterableIterator<Dirent> {\n          for (const entry of entries) {\n            yield entry\n          }\n        }\n      }\n    } catch (err) {\n      this.logError('opendir', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Watch for file changes\n   */\n  watch(path: string, options: WatchOptions = {}): FSWatcher {\n    this.log('watch', path, options)\n    const normalizedPath = normalize(path)\n    const { recursive = false, signal } = options\n\n    const callbacks = new Set<WatchCallback>()\n    const id = Symbol('watcher')\n\n    this.watchCallbacks.set(id, { path: normalizedPath, callbacks, recursive })\n\n    if (signal) {\n      signal.addEventListener('abort', () => {\n        this.watchCallbacks.delete(id)\n      })\n    }\n\n    const self = this\n\n    return {\n      close(): void {\n        self.watchCallbacks.delete(id)\n      },\n\n      ref(): FSWatcher {\n        return this\n      },\n\n      unref(): FSWatcher {\n        return this\n      },\n\n      [Symbol.asyncIterator](): AsyncIterator<{ eventType: 'rename' | 'change'; filename: string }> {\n        const queue: { eventType: 'rename' | 'change'; filename: string }[] = []\n        let resolver: ((value: IteratorResult<{ eventType: 'rename' | 'change'; filename: string }>) => void) | null = null\n\n        callbacks.add((eventType, filename) => {\n          const event = { eventType: eventType as 'rename' | 'change', filename }\n          if (resolver) {\n            resolver({ value: event, done: false })\n            resolver = null\n          } else {\n            queue.push(event)\n          }\n        })\n\n        return {\n          next(): Promise<IteratorResult<{ eventType: 'rename' | 'change'; filename: string }>> {\n            if (queue.length > 0) {\n              return Promise.resolve({ value: queue.shift()!, done: false })\n            }\n            return new Promise(resolve => {\n              resolver = resolve\n            })\n          },\n          return(): Promise<IteratorResult<{ eventType: 'rename' | 'change'; filename: string }>> {\n            return Promise.resolve({ done: true, value: undefined })\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Create read stream\n   */\n  createReadStream(path: string, options: ReadStreamOptions = {}): ReadableStream<Uint8Array> {\n    this.log('createReadStream', path, options)\n    const normalizedPath = normalize(path)\n    return createReadStream(normalizedPath, options, {\n      readFile: (p) => this.readFile(p) as Promise<Uint8Array>\n    })\n  }\n\n  /**\n   * Create write stream\n   */\n  createWriteStream(path: string, options: WriteStreamOptions = {}): WritableStream<Uint8Array> {\n    this.log('createWriteStream', path, options)\n    const normalizedPath = normalize(path)\n    return createWriteStream(normalizedPath, options, {\n      readFile: (p) => this.readFile(p) as Promise<Uint8Array>,\n      writeFile: (p, d) => this.writeFile(p, d)\n    })\n  }\n\n  /**\n   * Get file statistics (alias for stat)\n   */\n  async backFile(path: string): Promise<Stats> {\n    this.log('backFile', path)\n    try {\n      return await this.stat(normalize(path))\n    } catch (err) {\n      if ((err as { code?: string }).code === 'ENOENT') throw err\n      throw createENOENT(path)\n    }\n  }\n\n  /**\n   * Get disk usage for a path\n   */\n  async du(path: string): Promise<DiskUsage> {\n    if (this.hybrid) {\n      return this.hybrid.du(path)\n    }\n\n    this.log('du', path)\n    const normalizedPath = normalize(path)\n    const stat = await this.stat(normalizedPath)\n    return { path: normalizedPath, size: stat.size }\n  }\n\n  /**\n   * Get filesystem statistics (similar to Node.js fs.statfs)\n   * Uses the Storage API to get quota and usage information\n   * Note: Values are estimates for the entire origin, not per-path\n   */\n  async statfs(path?: string): Promise<StatFs> {\n    if (this.hybrid) {\n      return this.hybrid.statfs(path)\n    }\n\n    this.log('statfs', path)\n    try {\n      // Verify path exists if provided\n      if (path) {\n        await this.stat(normalize(path))\n      }\n\n      if (typeof navigator === 'undefined' || !navigator.storage?.estimate) {\n        throw new Error('Storage API not available')\n      }\n\n      const estimate = await navigator.storage.estimate()\n      const usage = estimate.usage ?? 0\n      const quota = estimate.quota ?? 0\n      const bsize = 4096 // Simulated block size\n\n      return {\n        type: 0,\n        bsize,\n        blocks: Math.floor(quota / bsize),\n        bfree: Math.floor((quota - usage) / bsize),\n        bavail: Math.floor((quota - usage) / bsize),\n        files: 0,\n        ffree: 0,\n        usage,\n        quota\n      }\n    } catch (err) {\n      this.logError('statfs', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Reset internal symlink cache\n   * Useful when external processes modify the filesystem\n   */\n  resetCache(): void {\n    if (this.hybrid) {\n      // For hybrid, this is async but we provide a sync interface for compatibility\n      // Use gc() for guaranteed cleanup\n      this.hybrid.resetCache()\n      return\n    }\n\n    this.symlinkManager.reset()\n    this.handleManager.clearCache()\n  }\n\n  /**\n   * Force full garbage collection\n   * Releases all handles and caches, reinitializes the worker in hybrid mode\n   * Use this for long-running operations to prevent memory leaks\n   */\n  async gc(): Promise<void> {\n    if (this.hybrid) {\n      await this.hybrid.gc()\n      return\n    }\n\n    this.symlinkManager.reset()\n    this.handleManager.clearCache()\n  }\n}\n","/**\n * OPFS Worker Proxy\n * Main thread class that communicates with an OPFS worker\n *\n * This allows non-blocking OPFS operations on the main thread\n * while the actual work happens in a dedicated Web Worker\n */\n\nimport type {\n  ReadFileOptions,\n  WriteFileOptions,\n  BatchWriteEntry,\n  BatchReadResult,\n  ReaddirOptions,\n  Dirent,\n  Stats,\n  StatFs,\n  RmOptions,\n  CpOptions,\n  DiskUsage,\n  SymlinkDefinition\n} from './types.js'\nimport { constants } from './constants.js'\nimport { FSError } from './errors.js'\n\ninterface PendingRequest {\n  resolve: (value: unknown) => void\n  reject: (error: Error) => void\n}\n\ninterface WorkerResponse {\n  id?: number\n  type?: string\n  result?: unknown\n  error?: { message: string; code?: string }\n}\n\nexport interface OPFSWorkerOptions {\n  /** URL to the worker script (default: auto-detect) */\n  workerUrl?: string | URL\n  /** Worker initialization options */\n  workerOptions?: WorkerOptions\n}\n\n/**\n * OPFS Worker Proxy - runs OPFS operations in a Web Worker\n *\n * Benefits:\n * - Non-blocking main thread\n * - Uses sync access handles (faster) in the worker\n * - Compatible with libraries that reuse buffers (e.g., isomorphic-git)\n */\nexport class OPFSWorker {\n  private worker: Worker | null = null\n  private pendingRequests = new Map<number, PendingRequest>()\n  private nextId = 1\n  private readyPromise: Promise<void>\n  private readyResolve!: () => void\n\n  /** File system constants */\n  public readonly constants = constants\n\n  constructor(options: OPFSWorkerOptions = {}) {\n    this.readyPromise = new Promise((resolve) => {\n      this.readyResolve = resolve\n    })\n\n    this.initWorker(options)\n  }\n\n  private initWorker(options: OPFSWorkerOptions): void {\n    const { workerUrl, workerOptions = { type: 'module' } } = options\n\n    if (workerUrl) {\n      this.worker = new Worker(workerUrl, workerOptions)\n    } else {\n      // Try to create worker from the bundled script\n      // Users should provide workerUrl in production\n      throw new Error(\n        'OPFSWorker requires a workerUrl option pointing to the worker script. ' +\n        'Example: new OPFSWorker({ workerUrl: new URL(\"./opfs-worker.js\", import.meta.url) })'\n      )\n    }\n\n    this.worker.onmessage = (event: MessageEvent<WorkerResponse>) => {\n      const { id, type, result, error } = event.data\n\n      // Handle ready signal\n      if (type === 'ready') {\n        this.readyResolve()\n        return\n      }\n\n      // Handle response to a request\n      if (id !== undefined) {\n        const pending = this.pendingRequests.get(id)\n        if (pending) {\n          this.pendingRequests.delete(id)\n          if (error) {\n            const fsError = new FSError(error.message, error.code || 'UNKNOWN')\n            pending.reject(fsError)\n          } else {\n            pending.resolve(result)\n          }\n        }\n      }\n    }\n\n    this.worker.onerror = (event) => {\n      console.error('[OPFSWorker] Worker error:', event)\n    }\n  }\n\n  /**\n   * Wait for the worker to be ready\n   */\n  async ready(): Promise<void> {\n    return this.readyPromise\n  }\n\n  /**\n   * Terminate the worker\n   */\n  terminate(): void {\n    if (this.worker) {\n      this.worker.terminate()\n      this.worker = null\n\n      // Reject all pending requests\n      for (const [, pending] of this.pendingRequests) {\n        pending.reject(new Error('Worker terminated'))\n      }\n      this.pendingRequests.clear()\n    }\n  }\n\n  private call<T>(method: string, args: unknown[], transfer?: Transferable[]): Promise<T> {\n    return new Promise((resolve, reject) => {\n      if (!this.worker) {\n        reject(new Error('Worker not initialized or terminated'))\n        return\n      }\n\n      const id = this.nextId++\n      this.pendingRequests.set(id, {\n        resolve: resolve as (value: unknown) => void,\n        reject\n      })\n\n      const message = { id, method, args }\n      if (transfer && transfer.length > 0) {\n        this.worker.postMessage(message, transfer)\n      } else {\n        this.worker.postMessage(message)\n      }\n    })\n  }\n\n  // File operations\n\n  async readFile(path: string, options?: ReadFileOptions): Promise<string | Uint8Array> {\n    const result = await this.call<string | Uint8Array>('readFile', [path, options])\n    return result\n  }\n\n  async writeFile(path: string, data: string | Uint8Array, options?: WriteFileOptions): Promise<void> {\n    // Note: We don't use Transferables here because the caller may reuse the buffer\n    // (e.g., isomorphic-git reuses buffers). Structured cloning copies the data.\n    await this.call<void>('writeFile', [path, data, options])\n  }\n\n  async readFileBatch(paths: string[]): Promise<BatchReadResult[]> {\n    return this.call<BatchReadResult[]>('readFileBatch', [paths])\n  }\n\n  async writeFileBatch(entries: BatchWriteEntry[]): Promise<void> {\n    // Note: We don't use Transferables here because the caller may reuse the buffers\n    await this.call<void>('writeFileBatch', [entries])\n  }\n\n  async appendFile(path: string, data: string | Uint8Array, options?: WriteFileOptions): Promise<void> {\n    // Note: We don't use Transferables here because the caller may reuse the buffer\n    await this.call<void>('appendFile', [path, data, options])\n  }\n\n  async copyFile(src: string, dest: string, mode?: number): Promise<void> {\n    await this.call<void>('copyFile', [src, dest, mode])\n  }\n\n  async unlink(path: string): Promise<void> {\n    await this.call<void>('unlink', [path])\n  }\n\n  async truncate(path: string, len?: number): Promise<void> {\n    await this.call<void>('truncate', [path, len])\n  }\n\n  // Directory operations\n\n  async mkdir(path: string): Promise<void> {\n    await this.call<void>('mkdir', [path])\n  }\n\n  async rmdir(path: string): Promise<void> {\n    await this.call<void>('rmdir', [path])\n  }\n\n  async readdir(path: string, options?: ReaddirOptions): Promise<string[] | Dirent[]> {\n    const result = await this.call<string[] | { name: string }[]>('readdir', [path, options])\n\n    // Reconstruct Dirent objects with methods\n    if (options?.withFileTypes && Array.isArray(result)) {\n      return result.map((item) => {\n        if (typeof item === 'object' && 'name' in item) {\n          const entry = item as { name: string; _isFile?: boolean; _isDir?: boolean; _isSymlink?: boolean }\n          return {\n            name: entry.name,\n            isFile: () => entry._isFile ?? false,\n            isDirectory: () => entry._isDir ?? false,\n            isSymbolicLink: () => entry._isSymlink ?? false\n          }\n        }\n        return item as unknown as Dirent\n      })\n    }\n\n    return result as string[]\n  }\n\n  async cp(src: string, dest: string, options?: CpOptions): Promise<void> {\n    await this.call<void>('cp', [src, dest, options])\n  }\n\n  async rm(path: string, options?: RmOptions): Promise<void> {\n    await this.call<void>('rm', [path, options])\n  }\n\n  // Stat operations\n\n  async stat(path: string): Promise<Stats> {\n    const result = await this.call<{\n      type: string\n      size: number\n      mode: number\n      ctime: string\n      ctimeMs: number\n      mtime: string\n      mtimeMs: number\n      target?: string\n    }>('stat', [path])\n\n    return this.deserializeStats(result)\n  }\n\n  async lstat(path: string): Promise<Stats> {\n    const result = await this.call<{\n      type: string\n      size: number\n      mode: number\n      ctime: string\n      ctimeMs: number\n      mtime: string\n      mtimeMs: number\n      target?: string\n    }>('lstat', [path])\n\n    return this.deserializeStats(result)\n  }\n\n  private deserializeStats(data: {\n    type: string\n    size: number\n    mode: number\n    ctime: string\n    ctimeMs: number\n    mtime: string\n    mtimeMs: number\n    target?: string\n  }): Stats {\n    const ctime = new Date(data.ctime)\n    const mtime = new Date(data.mtime)\n\n    return {\n      type: data.type as 'file' | 'dir' | 'symlink',\n      size: data.size,\n      mode: data.mode,\n      ctime,\n      ctimeMs: data.ctimeMs,\n      mtime,\n      mtimeMs: data.mtimeMs,\n      target: data.target,\n      isFile: () => data.type === 'file',\n      isDirectory: () => data.type === 'dir',\n      isSymbolicLink: () => data.type === 'symlink'\n    }\n  }\n\n  async exists(path: string): Promise<boolean> {\n    return this.call<boolean>('exists', [path])\n  }\n\n  async access(path: string, mode?: number): Promise<void> {\n    await this.call<void>('access', [path, mode])\n  }\n\n  async statfs(path?: string): Promise<StatFs> {\n    return this.call<StatFs>('statfs', [path])\n  }\n\n  async du(path: string): Promise<DiskUsage> {\n    return this.call<DiskUsage>('du', [path])\n  }\n\n  // Symlink operations\n\n  async symlink(target: string, path: string): Promise<void> {\n    await this.call<void>('symlink', [target, path])\n  }\n\n  async readlink(path: string): Promise<string> {\n    return this.call<string>('readlink', [path])\n  }\n\n  async symlinkBatch(links: SymlinkDefinition[]): Promise<void> {\n    await this.call<void>('symlinkBatch', [links])\n  }\n\n  async realpath(path: string): Promise<string> {\n    return this.call<string>('realpath', [path])\n  }\n\n  // Other operations\n\n  async rename(oldPath: string, newPath: string): Promise<void> {\n    await this.call<void>('rename', [oldPath, newPath])\n  }\n\n  async mkdtemp(prefix: string): Promise<string> {\n    return this.call<string>('mkdtemp', [prefix])\n  }\n\n  async chmod(path: string, mode: number): Promise<void> {\n    await this.call<void>('chmod', [path, mode])\n  }\n\n  async chown(path: string, uid: number, gid: number): Promise<void> {\n    await this.call<void>('chown', [path, uid, gid])\n  }\n\n  async utimes(path: string, atime: Date | number, mtime: Date | number): Promise<void> {\n    await this.call<void>('utimes', [path, atime, mtime])\n  }\n\n  async lutimes(path: string, atime: Date | number, mtime: Date | number): Promise<void> {\n    await this.call<void>('lutimes', [path, atime, mtime])\n  }\n\n  /**\n   * Reset internal caches to free memory\n   * Useful for long-running benchmarks or after bulk operations\n   */\n  async resetCache(): Promise<void> {\n    await this.call<void>('resetCache', [])\n  }\n\n  /**\n   * Force full garbage collection by reinitializing the OPFS instance in the worker\n   * This completely releases all handles and caches, preventing memory leaks in long-running operations\n   * More aggressive than resetCache() - use when resetCache() isn't sufficient\n   */\n  async gc(): Promise<void> {\n    await this.call<void>('gc', [])\n  }\n}\n","/**\n * OPFS Hybrid - Routes read/write operations to different backends\n *\n * Allows optimal performance by using:\n * - Main thread for reads (no message passing overhead)\n * - Worker for writes (sync access handles are faster)\n */\n\nimport OPFS from './index.js'\nimport { OPFSWorker } from './opfs-worker-proxy.js'\nimport type {\n  ReadFileOptions,\n  WriteFileOptions,\n  BatchWriteEntry,\n  BatchReadResult,\n  ReaddirOptions,\n  Stats,\n  StatFs,\n  RmOptions,\n  CpOptions,\n  SymlinkDefinition,\n  DiskUsage\n} from './types.js'\n\nexport type Backend = 'main' | 'worker'\n\nexport interface OPFSHybridOptions {\n  /** Backend for read operations (default: 'main') */\n  read?: Backend\n  /** Backend for write operations (default: 'worker') */\n  write?: Backend\n  /** Worker URL (required if using worker backend) */\n  workerUrl?: URL | string\n  /** Enable verbose logging */\n  verbose?: boolean\n}\n\n/**\n * Hybrid OPFS implementation that routes operations to optimal backends\n */\nexport class OPFSHybrid {\n  private mainFs: OPFS\n  private workerFs: OPFSWorker | null = null\n  private readBackend: Backend\n  private writeBackend: Backend\n  private workerUrl?: URL | string\n  private workerReady: Promise<void> | null = null\n  private verbose: boolean\n\n  constructor(options: OPFSHybridOptions = {}) {\n    this.readBackend = options.read ?? 'main'\n    this.writeBackend = options.write ?? 'worker'\n    this.workerUrl = options.workerUrl\n    this.verbose = options.verbose ?? false\n\n    // Always create main fs (needed for main backend or as fallback)\n    this.mainFs = new OPFS({ useSync: false, verbose: this.verbose })\n\n    // Create worker if needed\n    if (this.readBackend === 'worker' || this.writeBackend === 'worker') {\n      if (!this.workerUrl) {\n        throw new Error('workerUrl is required when using worker backend')\n      }\n      this.workerFs = new OPFSWorker({ workerUrl: this.workerUrl })\n      this.workerReady = this.workerFs.ready()\n    }\n  }\n\n  /**\n   * Wait for all backends to be ready\n   */\n  async ready(): Promise<void> {\n    if (this.workerReady) {\n      await this.workerReady\n    }\n  }\n\n  /**\n   * Terminate worker if active\n   */\n  terminate(): void {\n    if (this.workerFs) {\n      this.workerFs.terminate()\n      this.workerFs = null\n    }\n  }\n\n  private getReadFs(): OPFS | OPFSWorker {\n    if (this.readBackend === 'worker' && this.workerFs) {\n      return this.workerFs\n    }\n    return this.mainFs\n  }\n\n  private getWriteFs(): OPFS | OPFSWorker {\n    if (this.writeBackend === 'worker' && this.workerFs) {\n      return this.workerFs\n    }\n    return this.mainFs\n  }\n\n  // ============ Read Operations ============\n\n  async readFile(path: string, options?: ReadFileOptions): Promise<Uint8Array | string> {\n    return this.getReadFs().readFile(path, options)\n  }\n\n  async readFileBatch(paths: string[]): Promise<BatchReadResult[]> {\n    return this.getReadFs().readFileBatch(paths)\n  }\n\n  async readdir(path: string, options?: ReaddirOptions): Promise<string[] | import('./types.js').Dirent[]> {\n    return this.getReadFs().readdir(path, options)\n  }\n\n  async stat(path: string): Promise<Stats> {\n    return this.getReadFs().stat(path)\n  }\n\n  async lstat(path: string): Promise<Stats> {\n    return this.getReadFs().lstat(path)\n  }\n\n  async exists(path: string): Promise<boolean> {\n    return this.getReadFs().exists(path)\n  }\n\n  async access(path: string, mode?: number): Promise<void> {\n    return this.getReadFs().access(path, mode)\n  }\n\n  async readlink(path: string): Promise<string> {\n    return this.getReadFs().readlink(path)\n  }\n\n  async realpath(path: string): Promise<string> {\n    return this.getReadFs().realpath(path)\n  }\n\n  async statfs(path?: string): Promise<StatFs> {\n    return this.getReadFs().statfs(path)\n  }\n\n  async du(path: string): Promise<DiskUsage> {\n    return this.getReadFs().du(path)\n  }\n\n  // ============ Write Operations ============\n\n  async writeFile(path: string, data: string | Uint8Array, options?: WriteFileOptions): Promise<void> {\n    return this.getWriteFs().writeFile(path, data, options)\n  }\n\n  async writeFileBatch(entries: BatchWriteEntry[]): Promise<void> {\n    return this.getWriteFs().writeFileBatch(entries)\n  }\n\n  async appendFile(path: string, data: string | Uint8Array, options?: WriteFileOptions): Promise<void> {\n    return this.getWriteFs().appendFile(path, data, options)\n  }\n\n  async mkdir(path: string): Promise<void> {\n    return this.getWriteFs().mkdir(path)\n  }\n\n  async rmdir(path: string): Promise<void> {\n    // rmdir affects both backends' state\n    if (this.readBackend !== this.writeBackend && this.workerFs) {\n      // Clear via worker (does actual deletion and resets worker's symlink cache)\n      await this.workerFs.rmdir(path)\n      // Reset main thread's cache (no actual file operations, just cache invalidation)\n      this.mainFs.resetCache()\n    } else {\n      return this.getWriteFs().rmdir(path)\n    }\n  }\n\n  async unlink(path: string): Promise<void> {\n    return this.getWriteFs().unlink(path)\n  }\n\n  async truncate(path: string, len?: number): Promise<void> {\n    return this.getWriteFs().truncate(path, len)\n  }\n\n  async symlink(target: string, path: string): Promise<void> {\n    // Symlinks affect both backends' symlink cache\n    if (this.readBackend !== this.writeBackend && this.workerFs) {\n      await this.workerFs.symlink(target, path)\n      // Reset main thread's symlink cache so it reloads from disk\n      this.mainFs.resetCache()\n    } else {\n      return this.getWriteFs().symlink(target, path)\n    }\n  }\n\n  async symlinkBatch(symlinks: SymlinkDefinition[]): Promise<void> {\n    if (this.readBackend !== this.writeBackend && this.workerFs) {\n      await this.workerFs.symlinkBatch(symlinks)\n      // Reset main thread's symlink cache so it reloads from disk\n      this.mainFs.resetCache()\n    } else {\n      return this.getWriteFs().symlinkBatch(symlinks)\n    }\n  }\n\n  async rename(oldPath: string, newPath: string): Promise<void> {\n    return this.getWriteFs().rename(oldPath, newPath)\n  }\n\n  async copyFile(src: string, dest: string, mode?: number): Promise<void> {\n    return this.getWriteFs().copyFile(src, dest, mode)\n  }\n\n  async cp(src: string, dest: string, options?: CpOptions): Promise<void> {\n    return this.getWriteFs().cp(src, dest, options)\n  }\n\n  async rm(path: string, options?: RmOptions): Promise<void> {\n    return this.getWriteFs().rm(path, options)\n  }\n\n  async chmod(path: string, mode: number): Promise<void> {\n    return this.getWriteFs().chmod(path, mode)\n  }\n\n  async chown(path: string, uid: number, gid: number): Promise<void> {\n    return this.getWriteFs().chown(path, uid, gid)\n  }\n\n  async utimes(path: string, atime: Date | number, mtime: Date | number): Promise<void> {\n    return this.getWriteFs().utimes(path, atime, mtime)\n  }\n\n  async lutimes(path: string, atime: Date | number, mtime: Date | number): Promise<void> {\n    return this.getWriteFs().lutimes(path, atime, mtime)\n  }\n\n  async mkdtemp(prefix: string): Promise<string> {\n    return this.getWriteFs().mkdtemp(prefix)\n  }\n\n  /**\n   * Reset internal caches on both backends\n   */\n  async resetCache(): Promise<void> {\n    this.mainFs.resetCache()\n    if (this.workerFs) {\n      await this.workerFs.resetCache()\n    }\n  }\n\n  /**\n   * Force full garbage collection on both backends\n   * More aggressive than resetCache() - reinitializes the worker's OPFS instance\n   */\n  async gc(): Promise<void> {\n    this.mainFs.resetCache()\n    if (this.workerFs) {\n      await this.workerFs.gc()\n    }\n  }\n}\n\nexport default OPFSHybrid\n"]}