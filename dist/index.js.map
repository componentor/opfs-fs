{"version":3,"sources":["../src/constants.ts","../src/errors.ts","../src/path-utils.ts","../src/handle-manager.ts","../src/symlink-manager.ts","../src/file-handle.ts","../src/streams.ts","../src/index.ts"],"names":["position","name"],"mappings":"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","file":"index.js","sourcesContent":["import type { FSConstants } from './types.js'\n\n/**\n * File system constants matching Node.js fs.constants\n */\nexport const constants: FSConstants = {\n  // File access modes\n  F_OK: 0,\n  R_OK: 4,\n  W_OK: 2,\n  X_OK: 1,\n\n  // Copy file flags\n  COPYFILE_EXCL: 1,\n  COPYFILE_FICLONE: 2,\n  COPYFILE_FICLONE_FORCE: 4,\n\n  // File open flags\n  O_RDONLY: 0,\n  O_WRONLY: 1,\n  O_RDWR: 2,\n  O_CREAT: 64,\n  O_EXCL: 128,\n  O_TRUNC: 512,\n  O_APPEND: 1024,\n\n  // File type masks\n  S_IFMT: 61440,\n  S_IFREG: 32768,\n  S_IFDIR: 16384,\n  S_IFLNK: 40960\n}\n\n/**\n * Convert numeric flags to string representation\n */\nexport function flagsToString(flags: number | string): string {\n  if (typeof flags === 'string') return flags\n\n  const map: Record<number, string> = {\n    [constants.O_RDONLY]: 'r',\n    [constants.O_WRONLY]: 'w',\n    [constants.O_RDWR]: 'r+',\n    [constants.O_CREAT | constants.O_WRONLY]: 'w',\n    [constants.O_CREAT | constants.O_WRONLY | constants.O_TRUNC]: 'w',\n    [constants.O_CREAT | constants.O_RDWR]: 'w+',\n    [constants.O_APPEND | constants.O_WRONLY]: 'a',\n    [constants.O_APPEND | constants.O_RDWR]: 'a+'\n  }\n\n  return map[flags] || 'r'\n}\n","/**\n * Custom error class for filesystem errors\n */\nexport class FSError extends Error {\n  code: string\n  syscall?: string\n  path?: string\n  original?: Error\n\n  constructor(message: string, code: string, options?: { syscall?: string; path?: string; original?: Error }) {\n    super(message)\n    this.name = 'FSError'\n    this.code = code\n    this.syscall = options?.syscall\n    this.path = options?.path\n    this.original = options?.original\n  }\n}\n\n/**\n * Create ENOENT (No such file or directory) error\n */\nexport function createENOENT(path: string): FSError {\n  return new FSError(`ENOENT: No such file or directory, '${path}'`, 'ENOENT', { path })\n}\n\n/**\n * Create EEXIST (File exists) error\n */\nexport function createEEXIST(path: string, operation?: string): FSError {\n  const message = operation\n    ? `EEXIST: file already exists, ${operation} '${path}'`\n    : `EEXIST: File exists, '${path}'`\n  return new FSError(message, 'EEXIST', { path })\n}\n\n/**\n * Create EACCES (Permission denied) error\n */\nexport function createEACCES(path: string, syscall?: string): FSError {\n  return new FSError(`EACCES: permission denied, access '${path}'`, 'EACCES', { syscall, path })\n}\n\n/**\n * Create EISDIR (Is a directory) error\n */\nexport function createEISDIR(path: string, operation = 'operation'): FSError {\n  return new FSError(`EISDIR: illegal operation on a directory, ${operation} '${path}'`, 'EISDIR', { path })\n}\n\n/**\n * Create ELOOP (Too many symbolic links) error\n */\nexport function createELOOP(path: string): FSError {\n  return new FSError(`ELOOP: Too many symbolic links, '${path}'`, 'ELOOP', { path })\n}\n\n/**\n * Create EINVAL (Invalid argument) error\n */\nexport function createEINVAL(path: string): FSError {\n  return new FSError(`EINVAL: Invalid argument, '${path}'`, 'EINVAL', { path })\n}\n\n/**\n * Wrap an error with a standard code if it doesn't have one\n */\nexport function wrapError(err: unknown): FSError {\n  if (err instanceof FSError) return err\n\n  const error = err as Error\n  if (typeof (error as FSError).code === 'string') {\n    const fsErr = new FSError(error.message, (error as FSError).code)\n    fsErr.original = error\n    return fsErr\n  }\n\n  const wrapped = new FSError(error.message || 'Unknown error', 'UNKNOWN')\n  wrapped.original = error\n  return wrapped\n}\n","/**\n * Normalize a path, handling . and .. components\n */\nexport function normalize(path: string | undefined | null): string {\n  if (path === undefined || path === null) {\n    throw new TypeError('Path cannot be undefined or null')\n  }\n\n  if (typeof path !== 'string') {\n    throw new TypeError(`Expected string path, got ${typeof path}`)\n  }\n\n  if (path === '') {\n    return '/'\n  }\n\n  const parts = path.split('/')\n  const stack: string[] = []\n\n  for (const part of parts) {\n    if (part === '' || part === '.') {\n      continue\n    } else if (part === '..') {\n      if (stack.length > 0) stack.pop()\n    } else {\n      stack.push(part)\n    }\n  }\n\n  return '/' + stack.join('/')\n}\n\n/**\n * Get parent directory path\n */\nexport function dirname(path: string): string {\n  const normalized = normalize(path)\n  const parts = normalized.split('/').filter(Boolean)\n  if (parts.length < 2) return '/'\n  return '/' + parts.slice(0, -1).join('/')\n}\n\n/**\n * Get base filename\n */\nexport function basename(path: string): string {\n  const normalized = normalize(path)\n  const parts = normalized.split('/').filter(Boolean)\n  return parts[parts.length - 1] || ''\n}\n\n/**\n * Join path segments\n */\nexport function join(...paths: string[]): string {\n  return normalize(paths.join('/'))\n}\n\n/**\n * Check if path is root\n */\nexport function isRoot(path: string): boolean {\n  const normalized = normalize(path)\n  return normalized === '/' || normalized === ''\n}\n\n/**\n * Get path segments (excluding empty)\n */\nexport function segments(path: string): string[] {\n  return normalize(path).split('/').filter(Boolean)\n}\n","import { normalize, segments, dirname } from './path-utils.js'\nimport { createENOENT } from './errors.js'\n\nexport interface HandleResult {\n  dir: FileSystemDirectoryHandle\n  name: string\n  fileHandle: FileSystemFileHandle | null\n  dirHandle: FileSystemDirectoryHandle | null\n}\n\nexport interface GetHandleOptions {\n  create?: boolean\n  kind?: 'file' | 'directory'\n}\n\n/**\n * Manages OPFS handles with caching for improved performance\n */\nexport class HandleManager {\n  private rootPromise: Promise<FileSystemDirectoryHandle>\n  private dirCache: Map<string, FileSystemDirectoryHandle> = new Map()\n\n  constructor() {\n    this.rootPromise = navigator.storage.getDirectory()\n  }\n\n  /**\n   * Get the root directory handle\n   */\n  async getRoot(): Promise<FileSystemDirectoryHandle> {\n    return this.rootPromise\n  }\n\n  /**\n   * Clear directory cache for a path and its children\n   */\n  clearCache(path = ''): void {\n    const normalizedPath = normalize(path)\n    for (const key of this.dirCache.keys()) {\n      if (key === normalizedPath || key.startsWith(normalizedPath + '/')) {\n        this.dirCache.delete(key)\n      }\n    }\n  }\n\n  /**\n   * Get file or directory handle for a path\n   */\n  async getHandle(path: string, opts: GetHandleOptions = {}): Promise<HandleResult> {\n    const cleanPath = path.replace(/^\\/+/, '')\n    const parts = cleanPath.split('/').filter(Boolean)\n    let dir = await this.rootPromise\n\n    // Navigate to parent directory\n    for (let i = 0; i < parts.length - 1; i++) {\n      try {\n        dir = await dir.getDirectoryHandle(parts[i], { create: opts.create })\n      } catch {\n        if (!opts.create) throw createENOENT(path)\n        throw createENOENT(path)\n      }\n    }\n\n    const name = parts[parts.length - 1]\n\n    try {\n      if (opts.kind === 'directory') {\n        const dirHandle = await dir.getDirectoryHandle(name, { create: opts.create })\n        return { dir, name, fileHandle: null, dirHandle }\n      } else {\n        const fileHandle = await dir.getFileHandle(name, { create: opts.create })\n        return { dir, name, fileHandle, dirHandle: null }\n      }\n    } catch {\n      if (!opts.create) {\n        return { dir, name, fileHandle: null, dirHandle: null }\n      }\n      throw createENOENT(path)\n    }\n  }\n\n  /**\n   * Get directory handle with caching\n   */\n  async getDirectoryHandle(path: string): Promise<FileSystemDirectoryHandle> {\n    const normalizedPath = normalize(path)\n\n    if (normalizedPath === '/' || normalizedPath === '') {\n      return this.rootPromise\n    }\n\n    // Check cache first\n    if (this.dirCache.has(normalizedPath)) {\n      return this.dirCache.get(normalizedPath)!\n    }\n\n    const parts = segments(normalizedPath)\n    let dir = await this.rootPromise\n    let currentPath = ''\n\n    for (const part of parts) {\n      currentPath += '/' + part\n\n      if (this.dirCache.has(currentPath)) {\n        dir = this.dirCache.get(currentPath)!\n        continue\n      }\n\n      dir = await dir.getDirectoryHandle(part)\n      this.dirCache.set(currentPath, dir)\n    }\n\n    return dir\n  }\n\n  /**\n   * Ensure parent directory exists\n   */\n  async ensureParentDir(path: string): Promise<void> {\n    const parentPath = dirname(path)\n    if (parentPath === '/' || parentPath === '') return\n\n    const parts = segments(parentPath)\n    let dir = await this.rootPromise\n\n    for (const part of parts) {\n      dir = await dir.getDirectoryHandle(part, { create: true })\n    }\n  }\n\n  /**\n   * Create directory (with automatic parent creation)\n   */\n  async mkdir(path: string): Promise<void> {\n    const normalizedPath = normalize(path)\n    this.clearCache(normalizedPath)\n\n    const parts = segments(normalizedPath)\n    let dir = await this.rootPromise\n\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i]\n      const subPath = '/' + parts.slice(0, i + 1).join('/')\n\n      if (this.dirCache.has(subPath)) {\n        dir = this.dirCache.get(subPath)!\n      } else {\n        dir = await dir.getDirectoryHandle(part, { create: true })\n        this.dirCache.set(subPath, dir)\n      }\n    }\n  }\n}\n","import type { SymlinkCache, SymlinkDefinition } from './types.js'\nimport type { HandleManager } from './handle-manager.js'\nimport { normalize } from './path-utils.js'\nimport { createELOOP, createEINVAL, createEEXIST } from './errors.js'\n\nconst SYMLINK_FILE = '/.opfs-symlinks.json'\nconst MAX_SYMLINK_DEPTH = 10\n\n/**\n * Manages symbolic link emulation using a JSON metadata file\n */\nexport class SymlinkManager {\n  private cache: SymlinkCache | null = null\n  private dirty = false\n  private handleManager: HandleManager\n  private useSync: boolean\n\n  constructor(handleManager: HandleManager, useSync: boolean) {\n    this.handleManager = handleManager\n    this.useSync = useSync\n  }\n\n  /**\n   * Load symlinks from metadata file\n   */\n  async load(): Promise<SymlinkCache> {\n    if (this.cache !== null) return this.cache\n\n    try {\n      const { fileHandle } = await this.handleManager.getHandle(SYMLINK_FILE)\n      if (!fileHandle) {\n        this.cache = {}\n        return this.cache\n      }\n\n      const file = await fileHandle.getFile()\n      const text = await file.text()\n      this.cache = JSON.parse(text)\n    } catch {\n      this.cache = {}\n    }\n\n    return this.cache\n  }\n\n  /**\n   * Save symlinks to metadata file\n   */\n  async save(): Promise<void> {\n    if (!this.cache) return\n\n    const data = JSON.stringify(this.cache, null, 2)\n    const { fileHandle } = await this.handleManager.getHandle(SYMLINK_FILE, { create: true })\n\n    if (!fileHandle) return\n\n    const buffer = new TextEncoder().encode(data)\n\n    if (this.useSync) {\n      const access = await fileHandle.createSyncAccessHandle()\n      access.truncate(0)\n      let written = 0\n      while (written < buffer.length) {\n        written += access.write(buffer.subarray(written), { at: written })\n      }\n      access.close()\n    } else {\n      const writable = await fileHandle.createWritable()\n      await writable.write(buffer)\n      await writable.close()\n    }\n\n    this.dirty = false\n  }\n\n  /**\n   * Flush pending changes if dirty\n   */\n  async flush(): Promise<void> {\n    if (this.dirty) {\n      await this.save()\n    }\n  }\n\n  /**\n   * Resolve a path through symlinks\n   */\n  async resolve(path: string, maxDepth = MAX_SYMLINK_DEPTH): Promise<string> {\n    const symlinks = await this.load()\n    let currentPath = path\n    let depth = 0\n\n    while (symlinks[currentPath] && depth < maxDepth) {\n      currentPath = symlinks[currentPath]\n      depth++\n    }\n\n    if (depth >= maxDepth) {\n      throw createELOOP(path)\n    }\n\n    return currentPath\n  }\n\n  /**\n   * Check if a path is a symlink\n   */\n  async isSymlink(path: string): Promise<boolean> {\n    const symlinks = await this.load()\n    return !!symlinks[path]\n  }\n\n  /**\n   * Get symlink target\n   */\n  async readlink(path: string): Promise<string> {\n    const normalizedPath = normalize(path)\n    const symlinks = await this.load()\n\n    if (!symlinks[normalizedPath]) {\n      throw createEINVAL(path)\n    }\n\n    return symlinks[normalizedPath]\n  }\n\n  /**\n   * Create a symlink\n   */\n  async symlink(target: string, path: string, checkExists: () => Promise<void>): Promise<void> {\n    const normalizedPath = normalize(path)\n    const normalizedTarget = normalize(target)\n\n    const symlinks = await this.load()\n\n    if (symlinks[normalizedPath]) {\n      throw createEEXIST(normalizedPath)\n    }\n\n    await checkExists()\n\n    symlinks[normalizedPath] = normalizedTarget\n    this.dirty = true\n    await this.flush()\n  }\n\n  /**\n   * Create multiple symlinks efficiently\n   */\n  async symlinkBatch(\n    links: SymlinkDefinition[],\n    checkExists: (path: string) => Promise<void>\n  ): Promise<void> {\n    const symlinks = await this.load()\n\n    for (const { target, path } of links) {\n      const normalizedPath = normalize(path)\n      const normalizedTarget = normalize(target)\n\n      if (symlinks[normalizedPath]) {\n        throw createEEXIST(normalizedPath)\n      }\n\n      await checkExists(normalizedPath)\n\n      symlinks[normalizedPath] = normalizedTarget\n    }\n\n    this.dirty = true\n    await this.flush()\n  }\n\n  /**\n   * Remove a symlink\n   */\n  async unlink(path: string): Promise<boolean> {\n    const symlinks = await this.load()\n\n    if (symlinks[path]) {\n      delete symlinks[path]\n      this.dirty = true\n      await this.flush()\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * Rename/move a symlink\n   */\n  async rename(oldPath: string, newPath: string): Promise<boolean> {\n    const symlinks = await this.load()\n\n    if (symlinks[oldPath]) {\n      const target = symlinks[oldPath]\n      delete symlinks[oldPath]\n      symlinks[newPath] = target\n      this.dirty = true\n      await this.flush()\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * Get all symlinks in a directory\n   */\n  async getSymlinksInDir(dirPath: string): Promise<string[]> {\n    const symlinks = await this.load()\n    const result: string[] = []\n\n    for (const symlinkPath of Object.keys(symlinks)) {\n      const parts = symlinkPath.split('/').filter(Boolean)\n      const parentPath = '/' + parts.slice(0, -1).join('/')\n\n      if (parentPath === dirPath || (dirPath === '/' && parts.length === 1)) {\n        result.push(parts[parts.length - 1])\n      }\n    }\n\n    return result\n  }\n\n  /**\n   * Check if path is the symlink metadata file\n   */\n  isMetadataFile(name: string): boolean {\n    return name === SYMLINK_FILE.replace(/^\\/+/, '')\n  }\n}\n","import type { FileHandle, ReadResult, WriteResult, Stats, ReadFileOptions, WriteFileOptions } from './types.js'\n\nexport interface FileHandleContext {\n  readFile(path: string, options?: ReadFileOptions): Promise<string | Uint8Array>\n  writeFile(path: string, data: string | Uint8Array, options?: WriteFileOptions): Promise<void>\n  appendFile(path: string, data: string | Uint8Array, options?: WriteFileOptions): Promise<void>\n  stat(path: string): Promise<Stats>\n  truncate(path: string, len: number): Promise<void>\n}\n\n/**\n * Create a FileHandle-like object for the open() method\n */\nexport function createFileHandle(\n  resolvedPath: string,\n  initialPosition: number,\n  context: FileHandleContext\n): FileHandle {\n  let position = initialPosition\n\n  return {\n    fd: Math.floor(Math.random() * 1000000),\n\n    async read(\n      buffer: Uint8Array,\n      offset = 0,\n      length = buffer.length,\n      pos: number | null = null\n    ): Promise<ReadResult> {\n      const readPos = pos !== null ? pos : position\n      const data = await context.readFile(resolvedPath) as Uint8Array\n      const bytesToRead = Math.min(length, data.length - readPos)\n      buffer.set(data.subarray(readPos, readPos + bytesToRead), offset)\n      if (pos === null) position += bytesToRead\n      return { bytesRead: bytesToRead, buffer }\n    },\n\n    async write(\n      buffer: Uint8Array,\n      offset = 0,\n      length = buffer.length,\n      pos: number | null = null\n    ): Promise<WriteResult> {\n      const writePos = pos !== null ? pos : position\n      let existingData = new Uint8Array(0)\n\n      try {\n        existingData = await context.readFile(resolvedPath) as Uint8Array\n      } catch (e) {\n        if ((e as { code?: string }).code !== 'ENOENT') throw e\n      }\n\n      const dataToWrite = buffer.subarray(offset, offset + length)\n      const newSize = Math.max(existingData.length, writePos + length)\n      const newData = new Uint8Array(newSize)\n      newData.set(existingData, 0)\n      newData.set(dataToWrite, writePos)\n\n      await context.writeFile(resolvedPath, newData)\n      if (pos === null) position += length\n      return { bytesWritten: length, buffer }\n    },\n\n    async close(): Promise<void> {\n      // No-op for OPFS\n    },\n\n    async stat(): Promise<Stats> {\n      return context.stat(resolvedPath)\n    },\n\n    async truncate(len = 0): Promise<void> {\n      return context.truncate(resolvedPath, len)\n    },\n\n    async sync(): Promise<void> {\n      // No-op for OPFS (writes are already persisted)\n    },\n\n    async datasync(): Promise<void> {\n      // No-op for OPFS\n    },\n\n    async readFile(options?: ReadFileOptions): Promise<string | Uint8Array> {\n      return context.readFile(resolvedPath, options)\n    },\n\n    async writeFile(data: string | Uint8Array, options?: WriteFileOptions): Promise<void> {\n      return context.writeFile(resolvedPath, data, options)\n    },\n\n    async appendFile(data: string | Uint8Array, options?: WriteFileOptions): Promise<void> {\n      return context.appendFile(resolvedPath, data, options)\n    },\n\n    [Symbol.asyncDispose]: async function(): Promise<void> {\n      // No-op for OPFS\n    }\n  }\n}\n","import type { ReadStreamOptions, WriteStreamOptions } from './types.js'\n\nexport interface ReadStreamContext {\n  readFile(path: string): Promise<Uint8Array>\n}\n\nexport interface WriteStreamContext {\n  readFile(path: string): Promise<Uint8Array>\n  writeFile(path: string, data: Uint8Array): Promise<void>\n}\n\n/**\n * Create a ReadableStream for reading file contents\n */\nexport function createReadStream(\n  path: string,\n  options: ReadStreamOptions,\n  context: ReadStreamContext\n): ReadableStream<Uint8Array> {\n  const { start = 0, end = Infinity, highWaterMark = 64 * 1024 } = options\n  let position = start\n  let closed = false\n\n  return new ReadableStream({\n    async pull(controller) {\n      if (closed) {\n        controller.close()\n        return\n      }\n\n      try {\n        const data = await context.readFile(path)\n        const endPos = Math.min(end, data.length)\n        const chunk = data.subarray(position, Math.min(position + highWaterMark, endPos))\n\n        if (chunk.length === 0 || position >= endPos) {\n          controller.close()\n          closed = true\n          return\n        }\n\n        position += chunk.length\n        controller.enqueue(chunk)\n      } catch (err) {\n        controller.error(err)\n      }\n    },\n    cancel() {\n      closed = true\n    }\n  })\n}\n\n/**\n * Create a WritableStream for writing file contents\n */\nexport function createWriteStream(\n  path: string,\n  options: WriteStreamOptions,\n  context: WriteStreamContext\n): WritableStream<Uint8Array> {\n  const { flags = 'w', start = 0 } = options\n  const chunks: Array<{ data: Uint8Array; position: number }> = []\n  let position = start\n\n  return new WritableStream({\n    async write(chunk) {\n      chunks.push({ data: chunk, position })\n      position += chunk.length\n    },\n\n    async close() {\n      // Combine all chunks\n      let existingData = new Uint8Array(0)\n\n      if (!flags.includes('w')) {\n        try {\n          existingData = await context.readFile(path)\n        } catch (e) {\n          if ((e as { code?: string }).code !== 'ENOENT') throw e\n        }\n      }\n\n      let maxSize = existingData.length\n      for (const { data, position } of chunks) {\n        maxSize = Math.max(maxSize, position + data.length)\n      }\n\n      const finalData = new Uint8Array(maxSize)\n\n      if (!flags.includes('w')) {\n        finalData.set(existingData, 0)\n      }\n\n      for (const { data, position } of chunks) {\n        finalData.set(data, position)\n      }\n\n      await context.writeFile(path, finalData)\n    }\n  })\n}\n","import type {\n  OPFSOptions,\n  ReadFileOptions,\n  WriteFileOptions,\n  ReaddirOptions,\n  Dirent,\n  Stats,\n  StatFs,\n  RmOptions,\n  CpOptions,\n  WatchOptions,\n  FSWatcher,\n  ReadStreamOptions,\n  WriteStreamOptions,\n  FileHandle,\n  Dir,\n  DiskUsage,\n  SymlinkDefinition,\n  WatchCallback,\n  WatchRegistration\n} from './types.js'\nimport { constants, flagsToString } from './constants.js'\nimport { createENOENT, createEEXIST, createEACCES, createEISDIR, wrapError } from './errors.js'\nimport { normalize, dirname, basename, join, isRoot, segments } from './path-utils.js'\nimport { HandleManager } from './handle-manager.js'\nimport { SymlinkManager } from './symlink-manager.js'\nimport { createFileHandle } from './file-handle.js'\nimport { createReadStream, createWriteStream } from './streams.js'\n\nexport { constants }\nexport * from './types.js'\n\n/**\n * OPFS-based filesystem implementation compatible with Node.js fs/promises API\n */\nexport default class OPFS {\n  private useSync: boolean\n  private verbose: boolean\n  private handleManager: HandleManager\n  private symlinkManager: SymlinkManager\n  private watchCallbacks: Map<symbol, WatchRegistration> = new Map()\n  private tmpCounter = 0\n\n  /** File system constants */\n  public readonly constants = constants\n\n  constructor(options: OPFSOptions = {}) {\n    const { useSync = true, verbose = false } = options\n    this.useSync = useSync && typeof FileSystemFileHandle !== 'undefined' &&\n      'createSyncAccessHandle' in FileSystemFileHandle.prototype\n    this.verbose = verbose\n    this.handleManager = new HandleManager()\n    this.symlinkManager = new SymlinkManager(this.handleManager, this.useSync)\n  }\n\n  private log(method: string, ...args: unknown[]): void {\n    if (this.verbose) {\n      console.log(`[OPFS] ${method}:`, ...args)\n    }\n  }\n\n  private logError(method: string, err: unknown): void {\n    if (this.verbose) {\n      console.error(`[OPFS] ${method} error:`, err)\n    }\n  }\n\n  /**\n   * Read file contents\n   */\n  async readFile(path: string, options: ReadFileOptions = {}): Promise<string | Uint8Array> {\n    this.log('readFile', path, options)\n    try {\n      const normalizedPath = normalize(path)\n      const resolvedPath = await this.symlinkManager.resolve(normalizedPath)\n      const { fileHandle } = await this.handleManager.getHandle(resolvedPath)\n\n      if (!fileHandle) {\n        throw createENOENT(path)\n      }\n\n      let buffer: Uint8Array\n\n      if (this.useSync) {\n        const access = await fileHandle.createSyncAccessHandle()\n        const size = access.getSize()\n        buffer = new Uint8Array(size)\n        access.read(buffer)\n        access.close()\n      } else {\n        const file = await fileHandle.getFile()\n        buffer = new Uint8Array(await file.arrayBuffer())\n      }\n\n      return options.encoding\n        ? new TextDecoder(options.encoding).decode(buffer)\n        : buffer\n    } catch (err) {\n      this.logError('readFile', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Write data to a file\n   */\n  async writeFile(path: string, data: string | Uint8Array, options: WriteFileOptions = {}): Promise<void> {\n    this.log('writeFile', path)\n    try {\n      const normalizedPath = normalize(path)\n      const resolvedPath = await this.symlinkManager.resolve(normalizedPath)\n      this.handleManager.clearCache(resolvedPath)\n\n      const { fileHandle } = await this.handleManager.getHandle(resolvedPath, { create: true })\n      const buffer = typeof data === 'string' ? new TextEncoder().encode(data) : data\n\n      if (this.useSync) {\n        const access = await fileHandle!.createSyncAccessHandle()\n        access.truncate(0)\n        let written = 0\n        while (written < buffer.length) {\n          written += access.write(buffer.subarray(written), { at: written })\n        }\n        access.close()\n      } else {\n        const writable = await fileHandle!.createWritable()\n        await writable.write(buffer)\n        await writable.close()\n      }\n    } catch (err) {\n      this.logError('writeFile', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Create a directory\n   */\n  async mkdir(path: string): Promise<void> {\n    this.log('mkdir', path)\n    try {\n      await this.handleManager.mkdir(path)\n    } catch (err) {\n      this.logError('mkdir', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Remove a directory\n   */\n  async rmdir(path: string): Promise<void> {\n    this.log('rmdir', path)\n    try {\n      const normalizedPath = normalize(path)\n      this.handleManager.clearCache(normalizedPath)\n\n      const limitConcurrency = async <T>(\n        items: T[],\n        maxConcurrent: number,\n        taskFn: (item: T) => Promise<void>\n      ): Promise<void> => {\n        const queue = [...items]\n        const workers = Array.from({ length: maxConcurrent }).map(async () => {\n          while (queue.length) {\n            const item = queue.shift()\n            if (item !== undefined) await taskFn(item)\n          }\n        })\n        await Promise.all(workers)\n      }\n\n      if (isRoot(normalizedPath)) {\n        const root = await this.handleManager.getRoot()\n        const entries: string[] = []\n        for await (const [name] of root.entries()) {\n          entries.push(name)\n        }\n        await limitConcurrency(entries, 10, (name) =>\n          root.removeEntry(name, { recursive: true })\n        )\n        return\n      }\n\n      const pathSegments = segments(normalizedPath)\n      const name = pathSegments.pop()!\n      let dir = await this.handleManager.getRoot()\n\n      for (const part of pathSegments) {\n        dir = await dir.getDirectoryHandle(part)\n      }\n\n      try {\n        await dir.removeEntry(name, { recursive: true })\n      } catch {\n        throw createENOENT(path)\n      }\n    } catch (err) {\n      this.logError('rmdir', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Remove a file or symlink\n   */\n  async unlink(path: string): Promise<void> {\n    this.log('unlink', path)\n    try {\n      const normalizedPath = normalize(path)\n      this.handleManager.clearCache(normalizedPath)\n\n      const isSymlink = await this.symlinkManager.isSymlink(normalizedPath)\n      if (isSymlink) {\n        await this.symlinkManager.unlink(normalizedPath)\n        return\n      }\n\n      const { dir, name, fileHandle } = await this.handleManager.getHandle(normalizedPath)\n      if (!fileHandle) throw createENOENT(path)\n\n      try {\n        await dir!.removeEntry(name!)\n      } catch {\n        throw createENOENT(path)\n      }\n    } catch (err) {\n      this.logError('unlink', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Read directory contents\n   */\n  async readdir(path: string, options?: ReaddirOptions): Promise<string[] | Dirent[]> {\n    this.log('readdir', path, options)\n    try {\n      const normalizedPath = normalize(path)\n      const resolvedPath = await this.symlinkManager.resolve(normalizedPath)\n\n      const dir = await this.handleManager.getDirectoryHandle(resolvedPath)\n      const entries: (string | Dirent)[] = []\n\n      for await (const [name, handle] of dir.entries()) {\n        if (this.symlinkManager.isMetadataFile(name)) continue\n\n        const entryPath = resolvedPath === '/' ? `/${name}` : `${resolvedPath}/${name}`\n        const isSymlink = await this.symlinkManager.isSymlink(entryPath)\n\n        if (options?.withFileTypes) {\n          entries.push({\n            name,\n            isFile: () => !isSymlink && handle.kind === 'file',\n            isDirectory: () => !isSymlink && handle.kind === 'directory',\n            isSymbolicLink: () => isSymlink\n          })\n        } else {\n          entries.push(name)\n        }\n      }\n\n      // Add symlinks that exist in the directory\n      const symlinksInDir = await this.symlinkManager.getSymlinksInDir(resolvedPath)\n      for (const name of symlinksInDir) {\n        const exists = entries.some(e =>\n          typeof e === 'string' ? e === name : e.name === name\n        )\n        if (!exists) {\n          if (options?.withFileTypes) {\n            entries.push({\n              name,\n              isFile: () => false,\n              isDirectory: () => false,\n              isSymbolicLink: () => true\n            })\n          } else {\n            entries.push(name)\n          }\n        }\n      }\n\n      return entries as string[] | Dirent[]\n    } catch (err) {\n      this.logError('readdir', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Get file/directory statistics (follows symlinks)\n   */\n  async stat(path: string): Promise<Stats> {\n    this.log('stat', path)\n    try {\n      const normalizedPath = normalize(path)\n      const resolvedPath = await this.symlinkManager.resolve(normalizedPath)\n      const defaultDate = new Date(0)\n\n      if (isRoot(resolvedPath)) {\n        return {\n          type: 'dir',\n          size: 0,\n          mode: 0o040755,\n          ctime: defaultDate,\n          ctimeMs: 0,\n          mtime: defaultDate,\n          mtimeMs: 0,\n          isFile: () => false,\n          isDirectory: () => true,\n          isSymbolicLink: () => false\n        }\n      }\n\n      const pathSegments = segments(resolvedPath)\n      const name = pathSegments.pop()!\n      let dir = await this.handleManager.getRoot()\n\n      for (const part of pathSegments) {\n        try {\n          dir = await dir.getDirectoryHandle(part)\n        } catch {\n          throw createENOENT(path)\n        }\n      }\n\n      const [fileResult, dirResult] = await Promise.allSettled([\n        dir.getFileHandle(name),\n        dir.getDirectoryHandle(name)\n      ])\n\n      if (dirResult.status === 'fulfilled') {\n        return {\n          type: 'dir',\n          size: 0,\n          mode: 0o040755,\n          ctime: defaultDate,\n          ctimeMs: 0,\n          mtime: defaultDate,\n          mtimeMs: 0,\n          isFile: () => false,\n          isDirectory: () => true,\n          isSymbolicLink: () => false\n        }\n      }\n\n      if (fileResult.status === 'fulfilled') {\n        const fileHandle = fileResult.value\n        const file = await fileHandle.getFile()\n        const mtime = file.lastModified ? new Date(file.lastModified) : defaultDate\n\n        return {\n          type: 'file',\n          size: file.size,\n          mode: 0o100644,\n          ctime: mtime,\n          ctimeMs: mtime.getTime(),\n          mtime,\n          mtimeMs: mtime.getTime(),\n          isFile: () => true,\n          isDirectory: () => false,\n          isSymbolicLink: () => false\n        }\n      }\n\n      throw createENOENT(path)\n    } catch (err) {\n      this.logError('stat', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Get file/directory statistics (does not follow symlinks)\n   */\n  async lstat(path: string): Promise<Stats> {\n    this.log('lstat', path)\n    try {\n      const normalizedPath = normalize(path)\n      const isSymlink = await this.symlinkManager.isSymlink(normalizedPath)\n\n      if (isSymlink) {\n        const target = await this.symlinkManager.readlink(normalizedPath)\n        return {\n          type: 'symlink',\n          target,\n          size: target.length,\n          mode: 0o120777,\n          ctime: new Date(0),\n          ctimeMs: 0,\n          mtime: new Date(0),\n          mtimeMs: 0,\n          isFile: () => false,\n          isDirectory: () => false,\n          isSymbolicLink: () => true\n        }\n      }\n\n      return this.stat(path)\n    } catch (err) {\n      this.logError('lstat', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Rename a file or directory\n   */\n  async rename(oldPath: string, newPath: string): Promise<void> {\n    this.log('rename', oldPath, newPath)\n    try {\n      const normalizedOld = normalize(oldPath)\n      const normalizedNew = normalize(newPath)\n\n      this.handleManager.clearCache(normalizedOld)\n      this.handleManager.clearCache(normalizedNew)\n\n      // Handle symlink rename\n      const renamed = await this.symlinkManager.rename(normalizedOld, normalizedNew)\n      if (renamed) return\n\n      const stat = await this.stat(normalizedOld)\n\n      if (stat.isFile()) {\n        const data = await this.readFile(normalizedOld)\n        await this.handleManager.ensureParentDir(normalizedNew)\n        await this.writeFile(normalizedNew, data as Uint8Array)\n        await this.unlink(normalizedOld)\n      } else if (stat.isDirectory()) {\n        await this.mkdir(normalizedNew)\n        const entries = await this.readdir(normalizedOld) as string[]\n        for (const entry of entries) {\n          await this.rename(`${normalizedOld}/${entry}`, `${normalizedNew}/${entry}`)\n        }\n        await this.rmdir(normalizedOld)\n      }\n    } catch (err) {\n      this.logError('rename', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Create a symbolic link\n   */\n  async symlink(target: string, path: string): Promise<void> {\n    this.log('symlink', target, path)\n    try {\n      const normalizedPath = normalize(path)\n      this.handleManager.clearCache(normalizedPath)\n\n      await this.symlinkManager.symlink(target, path, async () => {\n        try {\n          await this.stat(normalizedPath)\n          throw createEEXIST(path)\n        } catch (err) {\n          if ((err as { code?: string }).code !== 'ENOENT') throw err\n        }\n      })\n    } catch (err) {\n      this.logError('symlink', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Read symlink target\n   */\n  async readlink(path: string): Promise<string> {\n    this.log('readlink', path)\n    try {\n      return await this.symlinkManager.readlink(path)\n    } catch (err) {\n      this.logError('readlink', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Create multiple symlinks efficiently\n   */\n  async symlinkBatch(links: SymlinkDefinition[]): Promise<void> {\n    this.log('symlinkBatch', links.length, 'links')\n    try {\n      for (const { path } of links) {\n        this.handleManager.clearCache(normalize(path))\n      }\n\n      await this.symlinkManager.symlinkBatch(links, async (normalizedPath) => {\n        try {\n          await this.stat(normalizedPath)\n          throw createEEXIST(normalizedPath)\n        } catch (err) {\n          if ((err as { code?: string }).code !== 'ENOENT') throw err\n        }\n      })\n    } catch (err) {\n      this.logError('symlinkBatch', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Check file accessibility\n   */\n  async access(path: string, mode = constants.F_OK): Promise<void> {\n    this.log('access', path, mode)\n    try {\n      const normalizedPath = normalize(path)\n      await this.stat(normalizedPath)\n      // OPFS doesn't have permissions, existence check is enough\n    } catch (err) {\n      this.logError('access', err)\n      throw createEACCES(path)\n    }\n  }\n\n  /**\n   * Append data to a file\n   */\n  async appendFile(path: string, data: string | Uint8Array, options: WriteFileOptions = {}): Promise<void> {\n    this.log('appendFile', path)\n    try {\n      const normalizedPath = normalize(path)\n      const resolvedPath = await this.symlinkManager.resolve(normalizedPath)\n\n      let existingData: Uint8Array = new Uint8Array(0)\n      try {\n        const result = await this.readFile(resolvedPath)\n        existingData = result instanceof Uint8Array ? result : new TextEncoder().encode(result)\n      } catch (err) {\n        if ((err as { code?: string }).code !== 'ENOENT') throw err\n      }\n\n      const newData = typeof data === 'string'\n        ? new TextEncoder().encode(data)\n        : data\n\n      const combined = new Uint8Array(existingData.length + newData.length)\n      combined.set(existingData, 0)\n      combined.set(newData, existingData.length)\n\n      await this.writeFile(resolvedPath, combined, options)\n    } catch (err) {\n      this.logError('appendFile', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Copy a file\n   */\n  async copyFile(src: string, dest: string, mode = 0): Promise<void> {\n    this.log('copyFile', src, dest, mode)\n    try {\n      const normalizedSrc = normalize(src)\n      const normalizedDest = normalize(dest)\n      const resolvedSrc = await this.symlinkManager.resolve(normalizedSrc)\n\n      // Check COPYFILE_EXCL flag\n      if (mode & constants.COPYFILE_EXCL) {\n        try {\n          await this.stat(normalizedDest)\n          throw createEEXIST(dest)\n        } catch (err) {\n          if ((err as { code?: string }).code !== 'ENOENT') throw err\n        }\n      }\n\n      const data = await this.readFile(resolvedSrc)\n      await this.handleManager.ensureParentDir(normalizedDest)\n      await this.writeFile(normalizedDest, data as Uint8Array)\n    } catch (err) {\n      this.logError('copyFile', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Copy files/directories recursively\n   */\n  async cp(src: string, dest: string, options: CpOptions = {}): Promise<void> {\n    this.log('cp', src, dest, options)\n    try {\n      const normalizedSrc = normalize(src)\n      const normalizedDest = normalize(dest)\n      const { recursive = false, force = false, errorOnExist = false } = options\n\n      const srcStat = await this.stat(normalizedSrc)\n\n      if (srcStat.isDirectory()) {\n        if (!recursive) {\n          throw createEISDIR(src)\n        }\n\n        let destExists = false\n        try {\n          await this.stat(normalizedDest)\n          destExists = true\n          if (errorOnExist && !force) {\n            throw createEEXIST(dest)\n          }\n        } catch (err) {\n          if ((err as { code?: string }).code !== 'ENOENT') throw err\n        }\n\n        if (!destExists) {\n          await this.mkdir(normalizedDest)\n        }\n\n        const entries = await this.readdir(normalizedSrc) as string[]\n        for (const entry of entries) {\n          await this.cp(`${normalizedSrc}/${entry}`, `${normalizedDest}/${entry}`, options)\n        }\n      } else {\n        if (errorOnExist) {\n          try {\n            await this.stat(normalizedDest)\n            throw createEEXIST(dest)\n          } catch (err) {\n            if ((err as { code?: string }).code !== 'ENOENT') throw err\n          }\n        }\n        await this.copyFile(normalizedSrc, normalizedDest)\n      }\n    } catch (err) {\n      this.logError('cp', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Check if path exists\n   */\n  async exists(path: string): Promise<boolean> {\n    this.log('exists', path)\n    try {\n      await this.stat(normalize(path))\n      return true\n    } catch {\n      return false\n    }\n  }\n\n  /**\n   * Resolve symlinks to get real path\n   */\n  async realpath(path: string): Promise<string> {\n    this.log('realpath', path)\n    const normalizedPath = normalize(path)\n    return this.symlinkManager.resolve(normalizedPath)\n  }\n\n  /**\n   * Remove files and directories\n   */\n  async rm(path: string, options: RmOptions = {}): Promise<void> {\n    this.log('rm', path, options)\n    try {\n      const normalizedPath = normalize(path)\n      const { recursive = false, force = false } = options\n\n      try {\n        const stat = await this.lstat(normalizedPath)\n\n        if (stat.isSymbolicLink()) {\n          await this.unlink(normalizedPath)\n        } else if (stat.isDirectory()) {\n          if (!recursive) {\n            throw createEISDIR(path)\n          }\n          await this.rmdir(normalizedPath)\n        } else {\n          await this.unlink(normalizedPath)\n        }\n      } catch (err) {\n        if ((err as { code?: string }).code === 'ENOENT' && force) {\n          return\n        }\n        throw err\n      }\n    } catch (err) {\n      this.logError('rm', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Truncate file to specified length\n   */\n  async truncate(path: string, len = 0): Promise<void> {\n    this.log('truncate', path, len)\n    try {\n      const normalizedPath = normalize(path)\n      const resolvedPath = await this.symlinkManager.resolve(normalizedPath)\n      this.handleManager.clearCache(resolvedPath)\n\n      const { fileHandle } = await this.handleManager.getHandle(resolvedPath)\n      if (!fileHandle) throw createENOENT(path)\n\n      if (this.useSync) {\n        const access = await fileHandle.createSyncAccessHandle()\n        access.truncate(len)\n        access.close()\n      } else {\n        const file = await fileHandle.getFile()\n        const data = new Uint8Array(await file.arrayBuffer())\n\n        // Create a new array with the truncated/padded size\n        const finalData = new Uint8Array(len)\n        // Copy up to len bytes from original data\n        const copyLen = Math.min(len, data.length)\n        for (let i = 0; i < copyLen; i++) {\n          finalData[i] = data[i]\n        }\n        // Remaining bytes (if any) are already zero from Uint8Array initialization\n\n        const writable = await fileHandle.createWritable()\n        await writable.write(finalData)\n        await writable.close()\n      }\n    } catch (err) {\n      this.logError('truncate', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Create a unique temporary directory\n   */\n  async mkdtemp(prefix: string): Promise<string> {\n    this.log('mkdtemp', prefix)\n    try {\n      const normalizedPrefix = normalize(prefix)\n      const suffix = `${Date.now()}-${++this.tmpCounter}-${Math.random().toString(36).slice(2, 8)}`\n      const path = `${normalizedPrefix}${suffix}`\n      await this.mkdir(path)\n      return path\n    } catch (err) {\n      this.logError('mkdtemp', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Change file mode (no-op for OPFS compatibility)\n   */\n  async chmod(path: string, mode: number): Promise<void> {\n    this.log('chmod', path, mode)\n    await this.stat(normalize(path))\n    // OPFS doesn't support file modes\n  }\n\n  /**\n   * Change file owner (no-op for OPFS compatibility)\n   */\n  async chown(path: string, uid: number, gid: number): Promise<void> {\n    this.log('chown', path, uid, gid)\n    await this.stat(normalize(path))\n    // OPFS doesn't support file ownership\n  }\n\n  /**\n   * Update file timestamps (no-op for OPFS compatibility)\n   */\n  async utimes(path: string, atime: Date | number, mtime: Date | number): Promise<void> {\n    this.log('utimes', path, atime, mtime)\n    await this.stat(normalize(path))\n    // OPFS doesn't support setting timestamps\n  }\n\n  /**\n   * Update symlink timestamps (no-op)\n   */\n  async lutimes(path: string, atime: Date | number, mtime: Date | number): Promise<void> {\n    this.log('lutimes', path, atime, mtime)\n    await this.lstat(normalize(path))\n    // OPFS doesn't support setting timestamps\n  }\n\n  /**\n   * Open file and return FileHandle\n   */\n  async open(path: string, flags: string | number = 'r', mode = 0o666): Promise<FileHandle> {\n    this.log('open', path, flags, mode)\n    try {\n      const normalizedPath = normalize(path)\n      const flagStr = flagsToString(flags)\n      const shouldCreate = flagStr.includes('w') || flagStr.includes('a') || flagStr.includes('+')\n      const shouldTruncate = flagStr.includes('w')\n      const shouldAppend = flagStr.includes('a')\n\n      if (shouldCreate) {\n        await this.handleManager.ensureParentDir(normalizedPath)\n      }\n\n      const resolvedPath = await this.symlinkManager.resolve(normalizedPath)\n      const { fileHandle } = await this.handleManager.getHandle(resolvedPath, { create: shouldCreate })\n\n      if (!fileHandle && !shouldCreate) {\n        throw createENOENT(path)\n      }\n\n      if (shouldTruncate && fileHandle) {\n        await this.truncate(resolvedPath, 0)\n      }\n\n      const initialPosition = shouldAppend ? (await this.stat(resolvedPath)).size : 0\n\n      return createFileHandle(resolvedPath, initialPosition, {\n        readFile: (p, o) => this.readFile(p, o),\n        writeFile: (p, d) => this.writeFile(p, d),\n        stat: (p) => this.stat(p),\n        truncate: (p, l) => this.truncate(p, l),\n        appendFile: (p, d, o) => this.appendFile(p, d, o)\n      })\n    } catch (err) {\n      this.logError('open', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Open directory for iteration\n   */\n  async opendir(path: string): Promise<Dir> {\n    this.log('opendir', path)\n    try {\n      const normalizedPath = normalize(path)\n      const entries = await this.readdir(normalizedPath, { withFileTypes: true }) as Dirent[]\n      let index = 0\n\n      return {\n        path: normalizedPath,\n\n        async read(): Promise<Dirent | null> {\n          if (index >= entries.length) return null\n          return entries[index++]\n        },\n\n        async close(): Promise<void> {\n          index = entries.length\n        },\n\n        async *[Symbol.asyncIterator](): AsyncIterableIterator<Dirent> {\n          for (const entry of entries) {\n            yield entry\n          }\n        }\n      }\n    } catch (err) {\n      this.logError('opendir', err)\n      throw wrapError(err)\n    }\n  }\n\n  /**\n   * Watch for file changes\n   */\n  watch(path: string, options: WatchOptions = {}): FSWatcher {\n    this.log('watch', path, options)\n    const normalizedPath = normalize(path)\n    const { recursive = false, signal } = options\n\n    const callbacks = new Set<WatchCallback>()\n    const id = Symbol('watcher')\n\n    this.watchCallbacks.set(id, { path: normalizedPath, callbacks, recursive })\n\n    if (signal) {\n      signal.addEventListener('abort', () => {\n        this.watchCallbacks.delete(id)\n      })\n    }\n\n    const self = this\n\n    return {\n      close(): void {\n        self.watchCallbacks.delete(id)\n      },\n\n      ref(): FSWatcher {\n        return this\n      },\n\n      unref(): FSWatcher {\n        return this\n      },\n\n      [Symbol.asyncIterator](): AsyncIterator<{ eventType: 'rename' | 'change'; filename: string }> {\n        const queue: { eventType: 'rename' | 'change'; filename: string }[] = []\n        let resolver: ((value: IteratorResult<{ eventType: 'rename' | 'change'; filename: string }>) => void) | null = null\n\n        callbacks.add((eventType, filename) => {\n          const event = { eventType: eventType as 'rename' | 'change', filename }\n          if (resolver) {\n            resolver({ value: event, done: false })\n            resolver = null\n          } else {\n            queue.push(event)\n          }\n        })\n\n        return {\n          next(): Promise<IteratorResult<{ eventType: 'rename' | 'change'; filename: string }>> {\n            if (queue.length > 0) {\n              return Promise.resolve({ value: queue.shift()!, done: false })\n            }\n            return new Promise(resolve => {\n              resolver = resolve\n            })\n          },\n          return(): Promise<IteratorResult<{ eventType: 'rename' | 'change'; filename: string }>> {\n            return Promise.resolve({ done: true, value: undefined })\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Create read stream\n   */\n  createReadStream(path: string, options: ReadStreamOptions = {}): ReadableStream<Uint8Array> {\n    this.log('createReadStream', path, options)\n    const normalizedPath = normalize(path)\n    return createReadStream(normalizedPath, options, {\n      readFile: (p) => this.readFile(p) as Promise<Uint8Array>\n    })\n  }\n\n  /**\n   * Create write stream\n   */\n  createWriteStream(path: string, options: WriteStreamOptions = {}): WritableStream<Uint8Array> {\n    this.log('createWriteStream', path, options)\n    const normalizedPath = normalize(path)\n    return createWriteStream(normalizedPath, options, {\n      readFile: (p) => this.readFile(p) as Promise<Uint8Array>,\n      writeFile: (p, d) => this.writeFile(p, d)\n    })\n  }\n\n  /**\n   * Get file statistics (alias for stat)\n   */\n  async backFile(path: string): Promise<Stats> {\n    this.log('backFile', path)\n    try {\n      return await this.stat(normalize(path))\n    } catch (err) {\n      if ((err as { code?: string }).code === 'ENOENT') throw err\n      throw createENOENT(path)\n    }\n  }\n\n  /**\n   * Get disk usage for a path\n   */\n  async du(path: string): Promise<DiskUsage> {\n    this.log('du', path)\n    const normalizedPath = normalize(path)\n    const stat = await this.stat(normalizedPath)\n    return { path: normalizedPath, size: stat.size }\n  }\n\n  /**\n   * Get filesystem statistics (similar to Node.js fs.statfs)\n   * Uses the Storage API to get quota and usage information\n   * Note: Values are estimates for the entire origin, not per-path\n   */\n  async statfs(path?: string): Promise<StatFs> {\n    this.log('statfs', path)\n    try {\n      // Verify path exists if provided\n      if (path) {\n        await this.stat(normalize(path))\n      }\n\n      if (typeof navigator === 'undefined' || !navigator.storage?.estimate) {\n        throw new Error('Storage API not available')\n      }\n\n      const estimate = await navigator.storage.estimate()\n      const usage = estimate.usage ?? 0\n      const quota = estimate.quota ?? 0\n      const bsize = 4096 // Simulated block size\n\n      return {\n        type: 0,\n        bsize,\n        blocks: Math.floor(quota / bsize),\n        bfree: Math.floor((quota - usage) / bsize),\n        bavail: Math.floor((quota - usage) / bsize),\n        files: 0,\n        ffree: 0,\n        usage,\n        quota\n      }\n    } catch (err) {\n      this.logError('statfs', err)\n      throw wrapError(err)\n    }\n  }\n}\n"]}