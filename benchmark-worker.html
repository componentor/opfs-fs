<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OPFS-FS Benchmark</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 1000px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    h1 { color: #333; }
    .card {
      background: white;
      border-radius: 8px;
      padding: 20px;
      margin: 15px 0;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .benchmark {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 0;
      border-bottom: 1px solid #eee;
    }
    .benchmark:last-child { border-bottom: none; }
    .benchmark-name { font-weight: 500; min-width: 180px; }
    .benchmark-result {
      font-family: monospace;
      padding: 4px 12px;
      border-radius: 4px;
      background: #e8f5e9;
      color: #2e7d32;
      min-width: 100px;
      text-align: center;
    }
    .benchmark-result.pending {
      background: #fff3e0;
      color: #ef6c00;
    }
    .benchmark-result.error {
      background: #ffebee;
      color: #c62828;
    }
    button {
      background: #1976d2;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 6px;
      font-size: 16px;
      cursor: pointer;
      margin: 5px;
    }
    button:hover { background: #1565c0; }
    button:disabled {
      background: #bdbdbd;
      cursor: not-allowed;
    }
    button.secondary {
      background: #7b1fa2;
    }
    button.secondary:hover {
      background: #6a1b9a;
    }
    button.tertiary {
      background: #00897b;
    }
    button.tertiary:hover {
      background: #00796b;
    }
    button.run-all {
      background: #ff5722;
    }
    button.run-all:hover {
      background: #e64a19;
    }
    button.lightning {
      background: #ffc107;
      color: #333;
    }
    button.lightning:hover {
      background: #ffb300;
    }
    #log {
      font-family: monospace;
      font-size: 12px;
      background: #263238;
      color: #aed581;
      padding: 15px;
      border-radius: 6px;
      max-height: 400px;
      overflow-y: auto;
      white-space: pre-wrap;
    }
    .summary {
      font-size: 18px;
      font-weight: bold;
      color: #1976d2;
      margin-top: 20px;
    }
    .comparison {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr 1fr;
      gap: 20px;
      margin-top: 10px;
    }
    .comparison-col {
      text-align: center;
    }
    .comparison-col h4 {
      margin: 0 0 10px 0;
      color: #666;
    }
    .comparison-value {
      font-size: 24px;
      font-weight: bold;
    }
    .comparison-value.main { color: #1976d2; }
    .comparison-value.worker { color: #7b1fa2; }
    .comparison-value.hybrid { color: #00897b; }
    .comparison-value.lightning { color: #ff8f00; }
    .mode-desc {
      font-size: 12px;
      color: #666;
      margin-top: 5px;
    }
    .iterations-input {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      margin-left: 10px;
    }
    .iterations-input input {
      width: 60px;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
    }
    .progress {
      font-size: 14px;
      color: #666;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <h1>OPFS-FS Benchmark: Main vs Worker vs Hybrid vs LightningFS</h1>

  <!-- Load LightningFS UMD bundle (exposes global LightningFS) -->
  <script src="./node_modules/@isomorphic-git/lightning-fs/dist/lightning-fs.min.js"></script>

  <div class="card">
    <p>Compare OPFS performance between different implementations:</p>
    <ul>
      <li><strong>Main Thread:</strong> Direct OPFS access, no message passing overhead for reads</li>
      <li><strong>Worker:</strong> Non-blocking, uses sync access handles (faster writes)</li>
      <li><strong>Hybrid:</strong> Best of both - main thread reads + worker writes</li>
      <li><strong>LightningFS:</strong> isomorphic-git's IndexedDB filesystem (for comparison)</li>
    </ul>
    <div>
      <button id="runMain" onclick="runMainBenchmarks()">Run Main Thread</button>
      <button id="runWorker" class="secondary" onclick="runWorkerBenchmarks()">Run Worker</button>
      <button id="runHybrid" class="tertiary" onclick="runHybridBenchmarks()">Run Hybrid</button>
      <button id="runLightning" class="lightning" onclick="runLightningBenchmarks()">Run LightningFS</button>
      <button onclick="clearStorage()">Clear All Storage</button>
    </div>
    <div style="margin-top: 15px;">
      <button id="runAll" class="run-all" onclick="runAllBenchmarks()">Run All (Average)</button>
      <span class="iterations-input">
        <label for="iterations">Iterations:</label>
        <input type="number" id="iterations" value="10" min="1" max="1000">
      </span>
      <span class="iterations-input">
        <label for="sequential">
          <input type="checkbox" id="sequential"> Sequential (run each backend separately)
        </label>
      </span>
    </div>
    <div class="progress" id="progress"></div>
  </div>

  <div class="card">
    <h3>Performance Comparison</h3>
    <div class="benchmark">
      <span class="benchmark-name">100 small file writes</span>
      <div style="display: flex; gap: 10px; flex-wrap: wrap;">
        <span class="benchmark-result pending" id="main-writes">Main: --</span>
        <span class="benchmark-result pending" id="worker-writes">Worker: --</span>
        <span class="benchmark-result pending" id="hybrid-writes">Hybrid: --</span>
        <span class="benchmark-result pending" id="lightning-writes">Lightning: --</span>
      </div>
    </div>
    <div class="benchmark">
      <span class="benchmark-name">100 small file reads</span>
      <div style="display: flex; gap: 10px; flex-wrap: wrap;">
        <span class="benchmark-result pending" id="main-reads">Main: --</span>
        <span class="benchmark-result pending" id="worker-reads">Worker: --</span>
        <span class="benchmark-result pending" id="hybrid-reads">Hybrid: --</span>
        <span class="benchmark-result pending" id="lightning-reads">Lightning: --</span>
      </div>
    </div>
    <div class="benchmark">
      <span class="benchmark-name">100 batch writes</span>
      <div style="display: flex; gap: 10px; flex-wrap: wrap;">
        <span class="benchmark-result pending" id="main-batch-writes">Main: --</span>
        <span class="benchmark-result pending" id="worker-batch-writes">Worker: --</span>
        <span class="benchmark-result pending" id="hybrid-batch-writes">Hybrid: --</span>
        <span class="benchmark-result pending" id="lightning-batch-writes">Lightning: --</span>
      </div>
    </div>
    <div class="benchmark">
      <span class="benchmark-name">100 batch reads</span>
      <div style="display: flex; gap: 10px; flex-wrap: wrap;">
        <span class="benchmark-result pending" id="main-batch-reads">Main: --</span>
        <span class="benchmark-result pending" id="worker-batch-reads">Worker: --</span>
        <span class="benchmark-result pending" id="hybrid-batch-reads">Hybrid: --</span>
        <span class="benchmark-result pending" id="lightning-batch-reads">Lightning: --</span>
      </div>
    </div>
    <div class="benchmark">
      <span class="benchmark-name">50 symlinks (batch)</span>
      <div style="display: flex; gap: 10px; flex-wrap: wrap;">
        <span class="benchmark-result pending" id="main-symlinks">Main: --</span>
        <span class="benchmark-result pending" id="worker-symlinks">Worker: --</span>
        <span class="benchmark-result pending" id="hybrid-symlinks">Hybrid: --</span>
        <span class="benchmark-result pending" id="lightning-symlinks">Lightning: N/A</span>
      </div>
    </div>
  </div>

  <div class="card">
    <h3>Console Log</h3>
    <div id="log"></div>
    <div class="comparison" id="comparison" style="display: none;">
      <div class="comparison-col">
        <h4>Main Thread Total</h4>
        <div class="comparison-value main" id="main-total">--</div>
        <div class="mode-desc">OPFS (main thread)</div>
      </div>
      <div class="comparison-col">
        <h4>Worker Total</h4>
        <div class="comparison-value worker" id="worker-total">--</div>
        <div class="mode-desc">OPFS (worker)</div>
      </div>
      <div class="comparison-col">
        <h4>Hybrid Total</h4>
        <div class="comparison-value hybrid" id="hybrid-total">--</div>
        <div class="mode-desc">OPFS (hybrid)</div>
      </div>
      <div class="comparison-col">
        <h4>LightningFS Total</h4>
        <div class="comparison-value lightning" id="lightning-total">--</div>
        <div class="mode-desc">IndexedDB</div>
      </div>
    </div>
  </div>

  <script type="module">
    // Import OPFS from dist
    import OPFS from './dist/index.js';
    import { OPFSWorker } from './dist/opfs-worker-proxy.js';
    import { OPFSHybrid } from './dist/opfs-hybrid.js';

    // LightningFS loaded via UMD bundle (global variable from script tag above)
    // Note: LightningFS uses IndexedDB which has different performance characteristics than OPFS

    const mainFs = new OPFS({ useSync: false, verbose: false });
    let workerFs = null;
    let hybridFs = null;
    let lightningFs = null;

    let mainResults = {};
    let workerResults = {};
    let hybridResults = {};
    let lightningResults = {};

    function log(msg) {
      const el = document.getElementById('log');
      el.textContent += msg + '\n';
      el.scrollTop = el.scrollHeight;
      console.log(msg);
    }

    function setResult(id, time, error = false, isAvg = false) {
      const el = document.getElementById(id);
      el.className = 'benchmark-result' + (error ? ' error' : '');
      const prefix = el.textContent.split(':')[0];
      if (error) {
        el.textContent = prefix + ': Error';
      } else {
        el.textContent = prefix + ': ' + time.toFixed(2) + 'ms' + (isAvg ? ' avg' : '');
      }
    }

    function setProgress(msg) {
      document.getElementById('progress').textContent = msg;
    }

    async function clearOPFS(fs = null) {
      try {
        if (fs) {
          await fs.rmdir('/');
        } else {
          await mainFs.rmdir('/');
        }
      } catch (e) {
        // Ignore clear errors
      }
    }

    async function clearLightningFS() {
      lightningFs = null;
      // Delete the IndexedDB database directly and wait for it
      try {
        await new Promise((resolve, reject) => {
          const req = indexedDB.deleteDatabase('benchmark-lightning-fs');
          req.onsuccess = resolve;
          req.onerror = () => resolve(); // Ignore errors
          req.onblocked = () => resolve();
        });
        // Small delay to ensure database is fully deleted
        await new Promise(r => setTimeout(r, 50));
      } catch (e) {
        // Ignore
      }
    }

    async function initLightning() {
      if (typeof LightningFS === 'undefined') {
        throw new Error('LightningFS not loaded - check that the UMD bundle is available');
      }
      // Create fresh instance (without wipe - we deleted the DB above)
      lightningFs = new LightningFS('benchmark-lightning-fs');
      log('  LightningFS instance created');

      // Initialize by doing a simple write/read to ensure DB is ready
      try {
        await lightningFs.promises.writeFile('/init-test.txt', 'test');
        await lightningFs.promises.unlink('/init-test.txt');
        log('  LightningFS initialization verified');
      } catch (e) {
        log('  LightningFS init error: ' + e.message);
        throw e;
      }
      return lightningFs;
    }

    // LightningFS wrapper to match OPFS-FS API
    // Uses a getter to always get the current LightningFS instance
    function createLightningWrapper() {
      // Helper to get current promises API
      const pfs = () => lightningFs.promises;

      // Helper to ensure directory exists
      async function ensureDir(path) {
        const parts = path.split('/').filter(p => p);
        let dir = '';
        for (let i = 0; i < parts.length - 1; i++) {
          dir += '/' + parts[i];
          try {
            await pfs().mkdir(dir);
          } catch (e) {
            // Directory may already exist (EEXIST) - ignore
          }
        }
      }

      return {
        async writeFile(path, data) {
          await ensureDir(path);
          await pfs().writeFile(path, data);
        },
        async readFile(path) {
          return await pfs().readFile(path, { encoding: 'utf8' });
        },
        async writeFileBatch(entries) {
          for (const entry of entries) {
            await this.writeFile(entry.path, entry.data);
          }
        },
        async readFileBatch(paths) {
          const results = [];
          for (const path of paths) {
            try {
              const data = await this.readFile(path);
              results.push({ path, data });
            } catch (e) {
              results.push({ path, data: null, error: e });
            }
          }
          return results;
        },
        async rmdir(path) {
          try {
            let entries;
            try {
              entries = await pfs().readdir(path);
            } catch (e) {
              return; // Directory doesn't exist
            }
            for (const entry of entries) {
              const fullPath = path === '/' ? '/' + entry : path + '/' + entry;
              try {
                const stat = await pfs().stat(fullPath);
                if (stat.isDirectory()) {
                  await this.rmdir(fullPath);
                } else {
                  await pfs().unlink(fullPath);
                }
              } catch (e) {
                // Ignore
              }
            }
            if (path !== '/') {
              await pfs().rmdir(path).catch(() => {});
            }
          } catch (e) {
            // Ignore
          }
        },
        async symlinkBatch(links) {
          for (const { target, path } of links) {
            await ensureDir(path);
            try {
              await pfs().symlink(target, path);
            } catch (e) {
              if (e.code === 'EEXIST') continue;
              throw e;
            }
          }
        },
        async gc() {
          // Just clear files like OPFS does - don't reinitialize
          await this.rmdir('/');
        }
      };
    }

    async function runBenchmarkSilent(fn, name = '') {
      try {
        const start = performance.now();
        await fn();
        return performance.now() - start;
      } catch (e) {
        console.error(`Benchmark error${name ? ` (${name})` : ''}:`, e);
        return -1;
      }
    }

    // Yield to browser event loop to prevent UI freeze
    function yieldToMain(ms = 0) {
      return new Promise(resolve => {
        // Use requestAnimationFrame + setTimeout for more reliable yielding
        requestAnimationFrame(() => setTimeout(resolve, ms));
      });
    }

    // Longer pause to allow garbage collection and prevent memory pressure
    function pauseForGC(ms = 100) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function runBenchmark(name, fn) {
      log(`Running: ${name}`);
      try {
        const start = performance.now();
        await fn();
        const duration = performance.now() - start;
        log(`  Completed in ${duration.toFixed(2)}ms`);
        return duration;
      } catch (e) {
        log(`  Error: ${e.message || e}`);
        console.error(`Benchmark error (${name}):`, e);
        return -1;
      }
    }

    // Core benchmark function that can run silently or with logging
    async function runCoreBenchmarks(fs, prefix, silent = false) {
      const results = {};

      // Clear storage before each benchmark run
      await clearOPFS(fs);
      if (silent) await yieldToMain();

      // Small file writes - yield every 25 operations to prevent freeze
      const writesFn = async () => {
        for (let i = 0; i < 100; i++) {
          await fs.writeFile(`/${prefix}/file${i}.txt`, 'x'.repeat(1024));
          if (silent && i % 25 === 24) await yieldToMain();
        }
      };
      results.writes = silent ? await runBenchmarkSilent(writesFn) : await runBenchmark('100 small file writes', writesFn);
      if (silent) await yieldToMain();

      // Small file reads - yield every 25 operations to prevent freeze
      const readsFn = async () => {
        for (let i = 0; i < 100; i++) {
          await fs.readFile(`/${prefix}/file${i}.txt`);
          if (silent && i % 25 === 24) await yieldToMain();
        }
      };
      results.reads = silent ? await runBenchmarkSilent(readsFn) : await runBenchmark('100 small file reads', readsFn);
      if (silent) await yieldToMain();

      // Batch writes
      const batchEntries = [];
      for (let i = 0; i < 100; i++) {
        batchEntries.push({ path: `/${prefix}/batch/file${i}.txt`, data: `batch content ${i}` });
      }
      const batchWritesFn = async () => {
        await fs.writeFileBatch(batchEntries);
      };
      results.batchWrites = silent ? await runBenchmarkSilent(batchWritesFn) : await runBenchmark('100 batch writes', batchWritesFn);
      if (silent) await yieldToMain();

      // Batch reads
      const batchPaths = batchEntries.map(e => e.path);
      const batchReadsFn = async () => {
        await fs.readFileBatch(batchPaths);
      };
      results.batchReads = silent ? await runBenchmarkSilent(batchReadsFn) : await runBenchmark('100 batch reads', batchReadsFn);
      if (silent) await yieldToMain();

      // Symlinks
      const symlinks = [];
      for (let i = 0; i < 50; i++) {
        symlinks.push({ target: `/${prefix}/file${i % 100}.txt`, path: `/${prefix}/links/link${i}` });
      }
      const symlinksFn = async () => {
        await fs.symlinkBatch(symlinks);
      };
      results.symlinks = silent ? await runBenchmarkSilent(symlinksFn) : await runBenchmark('50 symlinks (batch)', symlinksFn);

      return results;
    }

    async function initWorker() {
      if (!workerFs) {
        workerFs = new OPFSWorker({
          workerUrl: new URL('./dist/opfs-worker.js', import.meta.url)
        });
        await workerFs.ready();
      }
      return workerFs;
    }

    async function initHybrid() {
      if (!hybridFs) {
        hybridFs = new OPFSHybrid({
          read: 'main',
          write: 'worker',
          workerUrl: new URL('./dist/opfs-worker.js', import.meta.url)
        });
        await hybridFs.ready();
      }
      return hybridFs;
    }

    window.runMainBenchmarks = async function() {
      const btn = document.getElementById('runMain');
      btn.disabled = true;
      btn.textContent = 'Running...';
      document.getElementById('log').textContent = '';

      log('Starting Main Thread Benchmarks');
      log('================================');

      mainResults = await runCoreBenchmarks(mainFs, 'main', false);

      if (mainResults.writes > 0) setResult('main-writes', mainResults.writes);
      else setResult('main-writes', 0, true);
      if (mainResults.reads > 0) setResult('main-reads', mainResults.reads);
      else setResult('main-reads', 0, true);
      if (mainResults.batchWrites > 0) setResult('main-batch-writes', mainResults.batchWrites);
      else setResult('main-batch-writes', 0, true);
      if (mainResults.batchReads > 0) setResult('main-batch-reads', mainResults.batchReads);
      else setResult('main-batch-reads', 0, true);
      if (mainResults.symlinks > 0) setResult('main-symlinks', mainResults.symlinks);
      else setResult('main-symlinks', 0, true);

      const total = Object.values(mainResults).filter(v => v > 0).reduce((a, b) => a + b, 0);
      document.getElementById('main-total').textContent = total.toFixed(2) + 'ms';
      document.getElementById('comparison').style.display = 'grid';

      log('\nMain Thread Complete!');
      log(`Total: ${total.toFixed(2)}ms`);

      btn.disabled = false;
      btn.textContent = 'Run Main Thread';
    };

    window.runWorkerBenchmarks = async function() {
      const btn = document.getElementById('runWorker');
      btn.disabled = true;
      btn.textContent = 'Running...';
      document.getElementById('log').textContent = '';

      log('Starting Worker Benchmarks');
      log('==========================');

      try {
        log('Initializing worker...');
        await initWorker();
        log('Worker ready!');
      } catch (e) {
        log('Worker init error: ' + e.message);
        btn.disabled = false;
        btn.textContent = 'Run Worker';
        return;
      }

      workerResults = await runCoreBenchmarks(workerFs, 'worker', false);

      if (workerResults.writes > 0) setResult('worker-writes', workerResults.writes);
      else setResult('worker-writes', 0, true);
      if (workerResults.reads > 0) setResult('worker-reads', workerResults.reads);
      else setResult('worker-reads', 0, true);
      if (workerResults.batchWrites > 0) setResult('worker-batch-writes', workerResults.batchWrites);
      else setResult('worker-batch-writes', 0, true);
      if (workerResults.batchReads > 0) setResult('worker-batch-reads', workerResults.batchReads);
      else setResult('worker-batch-reads', 0, true);
      if (workerResults.symlinks > 0) setResult('worker-symlinks', workerResults.symlinks);
      else setResult('worker-symlinks', 0, true);

      const total = Object.values(workerResults).filter(v => v > 0).reduce((a, b) => a + b, 0);
      document.getElementById('worker-total').textContent = total.toFixed(2) + 'ms';
      document.getElementById('comparison').style.display = 'grid';

      log('\nWorker Complete!');
      log(`Total: ${total.toFixed(2)}ms`);

      btn.disabled = false;
      btn.textContent = 'Run Worker';
    };

    window.runHybridBenchmarks = async function() {
      const btn = document.getElementById('runHybrid');
      btn.disabled = true;
      btn.textContent = 'Running...';
      document.getElementById('log').textContent = '';

      log('Starting Hybrid Benchmarks');
      log('==========================');
      log('Mode: read=main, write=worker');

      try {
        log('Initializing hybrid...');
        await initHybrid();
        log('Hybrid ready!');
      } catch (e) {
        log('Hybrid init error: ' + e.message);
        console.error(e);
        btn.disabled = false;
        btn.textContent = 'Run Hybrid';
        return;
      }

      hybridResults = await runCoreBenchmarks(hybridFs, 'hybrid', false);

      if (hybridResults.writes > 0) setResult('hybrid-writes', hybridResults.writes);
      else setResult('hybrid-writes', 0, true);
      if (hybridResults.reads > 0) setResult('hybrid-reads', hybridResults.reads);
      else setResult('hybrid-reads', 0, true);
      if (hybridResults.batchWrites > 0) setResult('hybrid-batch-writes', hybridResults.batchWrites);
      else setResult('hybrid-batch-writes', 0, true);
      if (hybridResults.batchReads > 0) setResult('hybrid-batch-reads', hybridResults.batchReads);
      else setResult('hybrid-batch-reads', 0, true);
      if (hybridResults.symlinks > 0) setResult('hybrid-symlinks', hybridResults.symlinks);
      else setResult('hybrid-symlinks', 0, true);

      const total = Object.values(hybridResults).filter(v => v > 0).reduce((a, b) => a + b, 0);
      document.getElementById('hybrid-total').textContent = total.toFixed(2) + 'ms';
      document.getElementById('comparison').style.display = 'grid';

      log('\nHybrid Complete!');
      log(`Total: ${total.toFixed(2)}ms`);

      btn.disabled = false;
      btn.textContent = 'Run Hybrid';
    };

    window.runLightningBenchmarks = async function() {
      const btn = document.getElementById('runLightning');
      btn.disabled = true;
      btn.textContent = 'Running...';
      document.getElementById('log').textContent = '';

      log('Starting LightningFS Benchmarks');
      log('===============================');
      log('Backend: IndexedDB');

      try {
        if (typeof LightningFS === 'undefined') {
          throw new Error('LightningFS not loaded - check that the UMD bundle is available');
        }
        log('Initializing LightningFS...');
        await clearLightningFS();
        await initLightning();
        const wrapper = createLightningWrapper();
        log('LightningFS ready!\n');

        lightningResults = await runCoreBenchmarks(wrapper, 'lightning', false);

        if (lightningResults.writes > 0) setResult('lightning-writes', lightningResults.writes);
        else setResult('lightning-writes', 0, true);
        if (lightningResults.reads > 0) setResult('lightning-reads', lightningResults.reads);
        else setResult('lightning-reads', 0, true);
        if (lightningResults.batchWrites > 0) setResult('lightning-batch-writes', lightningResults.batchWrites);
        else setResult('lightning-batch-writes', 0, true);
        if (lightningResults.batchReads > 0) setResult('lightning-batch-reads', lightningResults.batchReads);
        else setResult('lightning-batch-reads', 0, true);
        if (lightningResults.symlinks > 0) setResult('lightning-symlinks', lightningResults.symlinks);
        else setResult('lightning-symlinks', 0, true);

        const total = Object.values(lightningResults).filter(v => v > 0).reduce((a, b) => a + b, 0);
        document.getElementById('lightning-total').textContent = total.toFixed(2) + 'ms';
        document.getElementById('comparison').style.display = 'grid';

        log('\nLightningFS Complete!');
        log(`Total: ${total.toFixed(2)}ms`);
      } catch (e) {
        log('LightningFS error: ' + e.message);
        console.error(e);
      }

      btn.disabled = false;
      btn.textContent = 'Run LightningFS';
    };

    window.runAllBenchmarks = async function() {
      const iterations = parseInt(document.getElementById('iterations').value) || 10;
      const sequential = document.getElementById('sequential').checked;
      const btn = document.getElementById('runAll');
      const btns = ['runMain', 'runWorker', 'runHybrid', 'runLightning', 'runAll'].map(id => document.getElementById(id));

      btns.forEach(b => b.disabled = true);
      btn.textContent = 'Running...';
      document.getElementById('log').textContent = '';

      const mode = sequential ? 'Sequential' : 'Interleaved';
      log(`Running All Benchmarks (${iterations} iterations, ${mode} mode)`);
      log('='.repeat(50));

      // Initialize all backends
      let lightningWrapper = null;
      try {
        log('Initializing backends...');
        await initWorker();
        await initHybrid();
        if (typeof LightningFS !== 'undefined') {
          await clearLightningFS();
          await initLightning();
          lightningWrapper = createLightningWrapper();
        } else {
          log('  LightningFS not available, skipping');
        }
        log('All backends ready!\n');
      } catch (e) {
        log('Init error: ' + e.message);
        console.error(e);
        btns.forEach(b => b.disabled = false);
        btn.textContent = 'Run All (Average)';
        return;
      }

      const allResults = {
        main: { totals: [], writes: [], reads: [], batchWrites: [], batchReads: [], symlinks: [] },
        worker: { totals: [], writes: [], reads: [], batchWrites: [], batchReads: [], symlinks: [] },
        hybrid: { totals: [], writes: [], reads: [], batchWrites: [], batchReads: [], symlinks: [] },
        lightning: { totals: [], writes: [], reads: [], batchWrites: [], batchReads: [], symlinks: [] }
      };

      const backends = [
        { name: 'main', getFs: () => mainFs, prefix: 'main' },
        { name: 'worker', getFs: () => workerFs, prefix: 'worker' },
        { name: 'hybrid', getFs: () => hybridFs, prefix: 'hybrid' }
      ];
      if (lightningWrapper) {
        backends.push({ name: 'lightning', getFs: () => lightningWrapper, prefix: 'lightning' });
      }

      // Helper to run one iteration for one backend
      async function runIteration(name, fs, prefix, iterNum) {
        await yieldToMain();
        const results = await runCoreBenchmarks(fs, prefix, true);
        const total = Object.values(results).filter(v => v > 0).reduce((a, b) => a + b, 0);

        allResults[name].totals.push(total);
        allResults[name].writes.push(results.writes);
        allResults[name].reads.push(results.reads);
        allResults[name].batchWrites.push(results.batchWrites);
        allResults[name].batchReads.push(results.batchReads);
        allResults[name].symlinks.push(results.symlinks);

        // Use gc() for aggressive cleanup (reinitializes worker OPFS instance)
        // or resetCache() for lighter cleanup
        if (fs.gc) {
          await fs.gc();
        } else if (fs.resetCache) {
          await fs.resetCache();
        }

        return total;
      }

      if (sequential) {
        // Sequential mode: run all iterations of each backend before moving to next
        for (const { name, getFs, prefix } of backends) {
          log(`\n=== ${name.toUpperCase()} (${iterations} iterations) ===`);

          for (let i = 0; i < iterations; i++) {
            setProgress(`${name}: ${i + 1}/${iterations}...`);

            const fs = getFs();
            const total = await runIteration(name, fs, prefix, i);
            log(`  [${i + 1}] ${total.toFixed(2)}ms`);

            // Brief pause to let browser process events
            if ((i + 1) % 10 === 0) {
              await pauseForGC(50);
            }
          }

          // Pause between backends
          log(`  Avg: ${(allResults[name].totals.reduce((a,b) => a+b, 0) / iterations).toFixed(2)}ms`);
          await pauseForGC(200);
        }
      } else {
        // Interleaved mode: cycle through backends each iteration
        for (let i = 0; i < iterations; i++) {
          setProgress(`Iteration ${i + 1}/${iterations}...`);
          log(`\n--- Iteration ${i + 1}/${iterations} ---`);

          for (const { name, getFs, prefix } of backends) {
            const fs = getFs();
            const total = await runIteration(name, fs, prefix, i);
            log(`  ${name}: ${total.toFixed(2)}ms`);
          }

          // Brief pause every 10 iterations
          if ((i + 1) % 10 === 0) {
            await pauseForGC(50);
          }
        }
      }

      // Calculate averages
      const avg = arr => arr.filter(v => v > 0).reduce((a, b) => a + b, 0) / arr.filter(v => v > 0).length;
      const stdDev = arr => {
        const validArr = arr.filter(v => v > 0);
        const mean = avg(validArr);
        return Math.sqrt(validArr.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / validArr.length);
      };

      log('\n' + '='.repeat(50));
      log(`RESULTS (${iterations} iterations)`);
      log('='.repeat(50));

      for (const name of ['main', 'worker', 'hybrid', 'lightning']) {
        const data = allResults[name];
        const avgTotal = avg(data.totals);
        const std = stdDev(data.totals);

        log(`\n${name.toUpperCase()}:`);
        log(`  Total:        ${avgTotal.toFixed(2)}ms (Â±${std.toFixed(2)}ms)`);
        log(`  Writes:       ${avg(data.writes).toFixed(2)}ms`);
        log(`  Reads:        ${avg(data.reads).toFixed(2)}ms`);
        log(`  Batch Writes: ${avg(data.batchWrites).toFixed(2)}ms`);
        log(`  Batch Reads:  ${avg(data.batchReads).toFixed(2)}ms`);
        log(`  Symlinks:     ${avg(data.symlinks).toFixed(2)}ms`);

        // Update UI
        setResult(`${name}-writes`, avg(data.writes), false, true);
        setResult(`${name}-reads`, avg(data.reads), false, true);
        setResult(`${name}-batch-writes`, avg(data.batchWrites), false, true);
        setResult(`${name}-batch-reads`, avg(data.batchReads), false, true);
        setResult(`${name}-symlinks`, avg(data.symlinks), false, true);
        document.getElementById(`${name}-total`).textContent = avgTotal.toFixed(2) + 'ms avg';
      }

      // Find winner
      const mainAvg = avg(allResults.main.totals);
      const workerAvg = avg(allResults.worker.totals);
      const hybridAvg = avg(allResults.hybrid.totals);
      const lightningAvg = avg(allResults.lightning.totals);
      const minAvg = Math.min(mainAvg, workerAvg, hybridAvg, lightningAvg);
      let winner = 'MAIN';
      if (minAvg === workerAvg) winner = 'WORKER';
      else if (minAvg === hybridAvg) winner = 'HYBRID';
      else if (minAvg === lightningAvg) winner = 'LIGHTNING';

      log('\n' + '='.repeat(50));
      log(`WINNER: ${winner} (${minAvg.toFixed(2)}ms average)`);
      log(`\nSpeedup vs LightningFS:`);
      log(`  Main:   ${(lightningAvg / mainAvg).toFixed(2)}x`);
      log(`  Worker: ${(lightningAvg / workerAvg).toFixed(2)}x`);
      log(`  Hybrid: ${(lightningAvg / hybridAvg).toFixed(2)}x`);
      log('='.repeat(50));

      document.getElementById('comparison').style.display = 'grid';
      setProgress(`Complete! Winner: ${winner}`);

      btns.forEach(b => b.disabled = false);
      btn.textContent = 'Run All (Average)';
    };

    window.clearStorage = async () => {
      log('Clearing all storage...');
      await clearOPFS();
      await clearLightningFS();
      log('All storage cleared (OPFS + IndexedDB)');
    };

    // Check OPFS support
    if (!navigator.storage?.getDirectory) {
      log('ERROR: OPFS is not supported in this browser!');
      document.getElementById('runMain').disabled = true;
      document.getElementById('runWorker').disabled = true;
      document.getElementById('runHybrid').disabled = true;
      document.getElementById('runAll').disabled = true;
    } else {
      log('OPFS is supported. Click buttons to run benchmarks.');
      log('Compare: Main Thread vs Worker vs Hybrid modes.');
    }
  </script>
</body>
</html>
