<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OPFS-FS Benchmark</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 1000px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    h1 { color: #333; }
    .card {
      background: white;
      border-radius: 8px;
      padding: 20px;
      margin: 15px 0;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .benchmark {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 0;
      border-bottom: 1px solid #eee;
    }
    .benchmark:last-child { border-bottom: none; }
    .benchmark-name { font-weight: 500; min-width: 180px; }
    .benchmark-result {
      font-family: monospace;
      padding: 4px 12px;
      border-radius: 4px;
      background: #e8f5e9;
      color: #2e7d32;
      min-width: 100px;
      text-align: center;
    }
    .benchmark-result.pending {
      background: #fff3e0;
      color: #ef6c00;
    }
    .benchmark-result.error {
      background: #ffebee;
      color: #c62828;
    }
    button {
      background: #1976d2;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 6px;
      font-size: 16px;
      cursor: pointer;
      margin: 5px;
    }
    button:hover { background: #1565c0; }
    button:disabled {
      background: #bdbdbd;
      cursor: not-allowed;
    }
    button.secondary {
      background: #7b1fa2;
    }
    button.secondary:hover {
      background: #6a1b9a;
    }
    button.tertiary {
      background: #00897b;
    }
    button.tertiary:hover {
      background: #00796b;
    }
    button.run-all {
      background: #ff5722;
    }
    button.run-all:hover {
      background: #e64a19;
    }
    #log {
      font-family: monospace;
      font-size: 12px;
      background: #263238;
      color: #aed581;
      padding: 15px;
      border-radius: 6px;
      max-height: 400px;
      overflow-y: auto;
      white-space: pre-wrap;
    }
    .summary {
      font-size: 18px;
      font-weight: bold;
      color: #1976d2;
      margin-top: 20px;
    }
    .comparison {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 20px;
      margin-top: 10px;
    }
    .comparison-col {
      text-align: center;
    }
    .comparison-col h4 {
      margin: 0 0 10px 0;
      color: #666;
    }
    .comparison-value {
      font-size: 24px;
      font-weight: bold;
    }
    .comparison-value.main { color: #1976d2; }
    .comparison-value.worker { color: #7b1fa2; }
    .comparison-value.hybrid { color: #00897b; }
    .mode-desc {
      font-size: 12px;
      color: #666;
      margin-top: 5px;
    }
    .iterations-input {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      margin-left: 10px;
    }
    .iterations-input input {
      width: 60px;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
    }
    .progress {
      font-size: 14px;
      color: #666;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <h1>OPFS-FS Benchmark: Main vs Worker vs Hybrid</h1>

  <div class="card">
    <p>Compare OPFS performance between different implementations:</p>
    <ul>
      <li><strong>Main Thread:</strong> Direct OPFS access, no message passing overhead for reads</li>
      <li><strong>Worker:</strong> Non-blocking, uses sync access handles (faster writes)</li>
      <li><strong>Hybrid:</strong> Best of both - main thread reads + worker writes</li>
    </ul>
    <div>
      <button id="runMain" onclick="runMainBenchmarks()">Run Main Thread</button>
      <button id="runWorker" class="secondary" onclick="runWorkerBenchmarks()">Run Worker</button>
      <button id="runHybrid" class="tertiary" onclick="runHybridBenchmarks()">Run Hybrid</button>
      <button onclick="clearOPFS()">Clear OPFS Storage</button>
    </div>
    <div style="margin-top: 15px;">
      <button id="runAll" class="run-all" onclick="runAllBenchmarks()">Run All (Average)</button>
      <span class="iterations-input">
        <label for="iterations">Iterations:</label>
        <input type="number" id="iterations" value="10" min="1" max="1000">
      </span>
      <span class="iterations-input">
        <label for="sequential">
          <input type="checkbox" id="sequential"> Sequential (run each backend separately)
        </label>
      </span>
    </div>
    <div class="progress" id="progress"></div>
  </div>

  <div class="card">
    <h3>Performance Comparison</h3>
    <div class="benchmark">
      <span class="benchmark-name">100 small file writes</span>
      <div style="display: flex; gap: 10px;">
        <span class="benchmark-result pending" id="main-writes">Main: --</span>
        <span class="benchmark-result pending" id="worker-writes">Worker: --</span>
        <span class="benchmark-result pending" id="hybrid-writes">Hybrid: --</span>
      </div>
    </div>
    <div class="benchmark">
      <span class="benchmark-name">100 small file reads</span>
      <div style="display: flex; gap: 10px;">
        <span class="benchmark-result pending" id="main-reads">Main: --</span>
        <span class="benchmark-result pending" id="worker-reads">Worker: --</span>
        <span class="benchmark-result pending" id="hybrid-reads">Hybrid: --</span>
      </div>
    </div>
    <div class="benchmark">
      <span class="benchmark-name">100 batch writes</span>
      <div style="display: flex; gap: 10px;">
        <span class="benchmark-result pending" id="main-batch-writes">Main: --</span>
        <span class="benchmark-result pending" id="worker-batch-writes">Worker: --</span>
        <span class="benchmark-result pending" id="hybrid-batch-writes">Hybrid: --</span>
      </div>
    </div>
    <div class="benchmark">
      <span class="benchmark-name">100 batch reads</span>
      <div style="display: flex; gap: 10px;">
        <span class="benchmark-result pending" id="main-batch-reads">Main: --</span>
        <span class="benchmark-result pending" id="worker-batch-reads">Worker: --</span>
        <span class="benchmark-result pending" id="hybrid-batch-reads">Hybrid: --</span>
      </div>
    </div>
    <div class="benchmark">
      <span class="benchmark-name">50 symlinks (batch)</span>
      <div style="display: flex; gap: 10px;">
        <span class="benchmark-result pending" id="main-symlinks">Main: --</span>
        <span class="benchmark-result pending" id="worker-symlinks">Worker: --</span>
        <span class="benchmark-result pending" id="hybrid-symlinks">Hybrid: --</span>
      </div>
    </div>
  </div>

  <div class="card">
    <h3>Console Log</h3>
    <div id="log"></div>
    <div class="comparison" id="comparison" style="display: none;">
      <div class="comparison-col">
        <h4>Main Thread Total</h4>
        <div class="comparison-value main" id="main-total">--</div>
        <div class="mode-desc">read: main, write: main</div>
      </div>
      <div class="comparison-col">
        <h4>Worker Total</h4>
        <div class="comparison-value worker" id="worker-total">--</div>
        <div class="mode-desc">read: worker, write: worker</div>
      </div>
      <div class="comparison-col">
        <h4>Hybrid Total</h4>
        <div class="comparison-value hybrid" id="hybrid-total">--</div>
        <div class="mode-desc">read: main, write: worker</div>
      </div>
    </div>
  </div>

  <script type="module">
    // Import OPFS from dist
    import OPFS from './dist/index.js';
    import { OPFSWorker } from './dist/opfs-worker-proxy.js';
    import { OPFSHybrid } from './dist/opfs-hybrid.js';

    const mainFs = new OPFS({ useSync: false, verbose: false });
    let workerFs = null;
    let hybridFs = null;

    let mainResults = {};
    let workerResults = {};
    let hybridResults = {};

    function log(msg) {
      const el = document.getElementById('log');
      el.textContent += msg + '\n';
      el.scrollTop = el.scrollHeight;
      console.log(msg);
    }

    function setResult(id, time, error = false, isAvg = false) {
      const el = document.getElementById(id);
      el.className = 'benchmark-result' + (error ? ' error' : '');
      const prefix = el.textContent.split(':')[0];
      if (error) {
        el.textContent = prefix + ': Error';
      } else {
        el.textContent = prefix + ': ' + time.toFixed(2) + 'ms' + (isAvg ? ' avg' : '');
      }
    }

    function setProgress(msg) {
      document.getElementById('progress').textContent = msg;
    }

    async function clearOPFS(fs = null) {
      try {
        if (fs) {
          await fs.rmdir('/');
        } else {
          await mainFs.rmdir('/');
        }
      } catch (e) {
        // Ignore clear errors
      }
    }

    async function runBenchmarkSilent(fn) {
      try {
        const start = performance.now();
        await fn();
        return performance.now() - start;
      } catch (e) {
        console.error(e);
        return -1;
      }
    }

    // Yield to browser event loop to prevent UI freeze
    function yieldToMain(ms = 0) {
      return new Promise(resolve => {
        // Use requestAnimationFrame + setTimeout for more reliable yielding
        requestAnimationFrame(() => setTimeout(resolve, ms));
      });
    }

    // Longer pause to allow garbage collection and prevent memory pressure
    function pauseForGC(ms = 100) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function runBenchmark(name, fn) {
      log(`Running: ${name}`);
      const duration = await runBenchmarkSilent(fn);
      if (duration > 0) {
        log(`  Completed in ${duration.toFixed(2)}ms`);
      } else {
        log(`  Error`);
      }
      return duration;
    }

    // Core benchmark function that can run silently or with logging
    async function runCoreBenchmarks(fs, prefix, silent = false) {
      const results = {};

      // Clear storage
      await clearOPFS(fs);
      if (silent) await yieldToMain();

      // Small file writes - yield every 25 operations to prevent freeze
      const writesFn = async () => {
        for (let i = 0; i < 100; i++) {
          await fs.writeFile(`/${prefix}/file${i}.txt`, 'x'.repeat(1024));
          if (silent && i % 25 === 24) await yieldToMain();
        }
      };
      results.writes = silent ? await runBenchmarkSilent(writesFn) : await runBenchmark('100 small file writes', writesFn);
      if (silent) await yieldToMain();

      // Small file reads - yield every 25 operations to prevent freeze
      const readsFn = async () => {
        for (let i = 0; i < 100; i++) {
          await fs.readFile(`/${prefix}/file${i}.txt`);
          if (silent && i % 25 === 24) await yieldToMain();
        }
      };
      results.reads = silent ? await runBenchmarkSilent(readsFn) : await runBenchmark('100 small file reads', readsFn);
      if (silent) await yieldToMain();

      // Batch writes
      const batchEntries = [];
      for (let i = 0; i < 100; i++) {
        batchEntries.push({ path: `/${prefix}/batch/file${i}.txt`, data: `batch content ${i}` });
      }
      const batchWritesFn = async () => {
        await fs.writeFileBatch(batchEntries);
      };
      results.batchWrites = silent ? await runBenchmarkSilent(batchWritesFn) : await runBenchmark('100 batch writes', batchWritesFn);
      if (silent) await yieldToMain();

      // Batch reads
      const batchPaths = batchEntries.map(e => e.path);
      const batchReadsFn = async () => {
        await fs.readFileBatch(batchPaths);
      };
      results.batchReads = silent ? await runBenchmarkSilent(batchReadsFn) : await runBenchmark('100 batch reads', batchReadsFn);
      if (silent) await yieldToMain();

      // Symlinks
      const symlinks = [];
      for (let i = 0; i < 50; i++) {
        symlinks.push({ target: `/${prefix}/file${i % 100}.txt`, path: `/${prefix}/links/link${i}` });
      }
      const symlinksFn = async () => {
        await fs.symlinkBatch(symlinks);
      };
      results.symlinks = silent ? await runBenchmarkSilent(symlinksFn) : await runBenchmark('50 symlinks (batch)', symlinksFn);

      return results;
    }

    async function initWorker() {
      if (!workerFs) {
        workerFs = new OPFSWorker({
          workerUrl: new URL('./dist/opfs-worker.js', import.meta.url)
        });
        await workerFs.ready();
      }
      return workerFs;
    }

    async function initHybrid() {
      if (!hybridFs) {
        hybridFs = new OPFSHybrid({
          read: 'main',
          write: 'worker',
          workerUrl: new URL('./dist/opfs-worker.js', import.meta.url)
        });
        await hybridFs.ready();
      }
      return hybridFs;
    }

    window.runMainBenchmarks = async function() {
      const btn = document.getElementById('runMain');
      btn.disabled = true;
      btn.textContent = 'Running...';
      document.getElementById('log').textContent = '';

      log('Starting Main Thread Benchmarks');
      log('================================');

      mainResults = await runCoreBenchmarks(mainFs, 'main', false);

      if (mainResults.writes > 0) setResult('main-writes', mainResults.writes);
      else setResult('main-writes', 0, true);
      if (mainResults.reads > 0) setResult('main-reads', mainResults.reads);
      else setResult('main-reads', 0, true);
      if (mainResults.batchWrites > 0) setResult('main-batch-writes', mainResults.batchWrites);
      else setResult('main-batch-writes', 0, true);
      if (mainResults.batchReads > 0) setResult('main-batch-reads', mainResults.batchReads);
      else setResult('main-batch-reads', 0, true);
      if (mainResults.symlinks > 0) setResult('main-symlinks', mainResults.symlinks);
      else setResult('main-symlinks', 0, true);

      const total = Object.values(mainResults).filter(v => v > 0).reduce((a, b) => a + b, 0);
      document.getElementById('main-total').textContent = total.toFixed(2) + 'ms';
      document.getElementById('comparison').style.display = 'grid';

      log('\nMain Thread Complete!');
      log(`Total: ${total.toFixed(2)}ms`);

      btn.disabled = false;
      btn.textContent = 'Run Main Thread';
    };

    window.runWorkerBenchmarks = async function() {
      const btn = document.getElementById('runWorker');
      btn.disabled = true;
      btn.textContent = 'Running...';
      document.getElementById('log').textContent = '';

      log('Starting Worker Benchmarks');
      log('==========================');

      try {
        log('Initializing worker...');
        await initWorker();
        log('Worker ready!');
      } catch (e) {
        log('Worker init error: ' + e.message);
        btn.disabled = false;
        btn.textContent = 'Run Worker';
        return;
      }

      workerResults = await runCoreBenchmarks(workerFs, 'worker', false);

      if (workerResults.writes > 0) setResult('worker-writes', workerResults.writes);
      else setResult('worker-writes', 0, true);
      if (workerResults.reads > 0) setResult('worker-reads', workerResults.reads);
      else setResult('worker-reads', 0, true);
      if (workerResults.batchWrites > 0) setResult('worker-batch-writes', workerResults.batchWrites);
      else setResult('worker-batch-writes', 0, true);
      if (workerResults.batchReads > 0) setResult('worker-batch-reads', workerResults.batchReads);
      else setResult('worker-batch-reads', 0, true);
      if (workerResults.symlinks > 0) setResult('worker-symlinks', workerResults.symlinks);
      else setResult('worker-symlinks', 0, true);

      const total = Object.values(workerResults).filter(v => v > 0).reduce((a, b) => a + b, 0);
      document.getElementById('worker-total').textContent = total.toFixed(2) + 'ms';
      document.getElementById('comparison').style.display = 'grid';

      log('\nWorker Complete!');
      log(`Total: ${total.toFixed(2)}ms`);

      btn.disabled = false;
      btn.textContent = 'Run Worker';
    };

    window.runHybridBenchmarks = async function() {
      const btn = document.getElementById('runHybrid');
      btn.disabled = true;
      btn.textContent = 'Running...';
      document.getElementById('log').textContent = '';

      log('Starting Hybrid Benchmarks');
      log('==========================');
      log('Mode: read=main, write=worker');

      try {
        log('Initializing hybrid...');
        await initHybrid();
        log('Hybrid ready!');
      } catch (e) {
        log('Hybrid init error: ' + e.message);
        console.error(e);
        btn.disabled = false;
        btn.textContent = 'Run Hybrid';
        return;
      }

      hybridResults = await runCoreBenchmarks(hybridFs, 'hybrid', false);

      if (hybridResults.writes > 0) setResult('hybrid-writes', hybridResults.writes);
      else setResult('hybrid-writes', 0, true);
      if (hybridResults.reads > 0) setResult('hybrid-reads', hybridResults.reads);
      else setResult('hybrid-reads', 0, true);
      if (hybridResults.batchWrites > 0) setResult('hybrid-batch-writes', hybridResults.batchWrites);
      else setResult('hybrid-batch-writes', 0, true);
      if (hybridResults.batchReads > 0) setResult('hybrid-batch-reads', hybridResults.batchReads);
      else setResult('hybrid-batch-reads', 0, true);
      if (hybridResults.symlinks > 0) setResult('hybrid-symlinks', hybridResults.symlinks);
      else setResult('hybrid-symlinks', 0, true);

      const total = Object.values(hybridResults).filter(v => v > 0).reduce((a, b) => a + b, 0);
      document.getElementById('hybrid-total').textContent = total.toFixed(2) + 'ms';
      document.getElementById('comparison').style.display = 'grid';

      log('\nHybrid Complete!');
      log(`Total: ${total.toFixed(2)}ms`);

      btn.disabled = false;
      btn.textContent = 'Run Hybrid';
    };

    window.runAllBenchmarks = async function() {
      const iterations = parseInt(document.getElementById('iterations').value) || 10;
      const sequential = document.getElementById('sequential').checked;
      const btn = document.getElementById('runAll');
      const btns = ['runMain', 'runWorker', 'runHybrid', 'runAll'].map(id => document.getElementById(id));

      btns.forEach(b => b.disabled = true);
      btn.textContent = 'Running...';
      document.getElementById('log').textContent = '';

      const mode = sequential ? 'Sequential' : 'Interleaved';
      log(`Running All Benchmarks (${iterations} iterations, ${mode} mode)`);
      log('='.repeat(50));

      // Initialize all backends
      try {
        log('Initializing backends...');
        await initWorker();
        await initHybrid();
        log('All backends ready!\n');
      } catch (e) {
        log('Init error: ' + e.message);
        btns.forEach(b => b.disabled = false);
        btn.textContent = 'Run All (Average)';
        return;
      }

      const allResults = {
        main: { totals: [], writes: [], reads: [], batchWrites: [], batchReads: [], symlinks: [] },
        worker: { totals: [], writes: [], reads: [], batchWrites: [], batchReads: [], symlinks: [] },
        hybrid: { totals: [], writes: [], reads: [], batchWrites: [], batchReads: [], symlinks: [] }
      };

      const backends = [
        { name: 'main', getFs: () => mainFs, prefix: 'main' },
        { name: 'worker', getFs: () => workerFs, prefix: 'worker' },
        { name: 'hybrid', getFs: () => hybridFs, prefix: 'hybrid' }
      ];

      // Helper to run one iteration for one backend
      async function runIteration(name, fs, prefix, iterNum) {
        await yieldToMain();
        const results = await runCoreBenchmarks(fs, prefix, true);
        const total = Object.values(results).filter(v => v > 0).reduce((a, b) => a + b, 0);

        allResults[name].totals.push(total);
        allResults[name].writes.push(results.writes);
        allResults[name].reads.push(results.reads);
        allResults[name].batchWrites.push(results.batchWrites);
        allResults[name].batchReads.push(results.batchReads);
        allResults[name].symlinks.push(results.symlinks);

        // Use gc() for aggressive cleanup (reinitializes worker OPFS instance)
        // or resetCache() for lighter cleanup
        if (fs.gc) {
          await fs.gc();
        } else if (fs.resetCache) {
          await fs.resetCache();
        }

        return total;
      }

      if (sequential) {
        // Sequential mode: run all iterations of each backend before moving to next
        for (const { name, getFs, prefix } of backends) {
          log(`\n=== ${name.toUpperCase()} (${iterations} iterations) ===`);

          for (let i = 0; i < iterations; i++) {
            setProgress(`${name}: ${i + 1}/${iterations}...`);

            const fs = getFs();
            const total = await runIteration(name, fs, prefix, i);
            log(`  [${i + 1}] ${total.toFixed(2)}ms`);

            // Brief pause to let browser process events
            if ((i + 1) % 10 === 0) {
              await pauseForGC(50);
            }
          }

          // Pause between backends
          log(`  Avg: ${(allResults[name].totals.reduce((a,b) => a+b, 0) / iterations).toFixed(2)}ms`);
          await pauseForGC(200);
        }
      } else {
        // Interleaved mode: cycle through backends each iteration
        for (let i = 0; i < iterations; i++) {
          setProgress(`Iteration ${i + 1}/${iterations}...`);
          log(`\n--- Iteration ${i + 1}/${iterations} ---`);

          for (const { name, getFs, prefix } of backends) {
            const fs = getFs();
            const total = await runIteration(name, fs, prefix, i);
            log(`  ${name}: ${total.toFixed(2)}ms`);
          }

          // Brief pause every 10 iterations
          if ((i + 1) % 10 === 0) {
            await pauseForGC(50);
          }
        }
      }

      // Calculate averages
      const avg = arr => arr.filter(v => v > 0).reduce((a, b) => a + b, 0) / arr.filter(v => v > 0).length;
      const stdDev = arr => {
        const validArr = arr.filter(v => v > 0);
        const mean = avg(validArr);
        return Math.sqrt(validArr.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / validArr.length);
      };

      log('\n' + '='.repeat(50));
      log(`RESULTS (${iterations} iterations)`);
      log('='.repeat(50));

      for (const name of ['main', 'worker', 'hybrid']) {
        const data = allResults[name];
        const avgTotal = avg(data.totals);
        const std = stdDev(data.totals);

        log(`\n${name.toUpperCase()}:`);
        log(`  Total:        ${avgTotal.toFixed(2)}ms (Â±${std.toFixed(2)}ms)`);
        log(`  Writes:       ${avg(data.writes).toFixed(2)}ms`);
        log(`  Reads:        ${avg(data.reads).toFixed(2)}ms`);
        log(`  Batch Writes: ${avg(data.batchWrites).toFixed(2)}ms`);
        log(`  Batch Reads:  ${avg(data.batchReads).toFixed(2)}ms`);
        log(`  Symlinks:     ${avg(data.symlinks).toFixed(2)}ms`);

        // Update UI
        setResult(`${name}-writes`, avg(data.writes), false, true);
        setResult(`${name}-reads`, avg(data.reads), false, true);
        setResult(`${name}-batch-writes`, avg(data.batchWrites), false, true);
        setResult(`${name}-batch-reads`, avg(data.batchReads), false, true);
        setResult(`${name}-symlinks`, avg(data.symlinks), false, true);
        document.getElementById(`${name}-total`).textContent = avgTotal.toFixed(2) + 'ms avg';
      }

      // Find winner
      const mainAvg = avg(allResults.main.totals);
      const workerAvg = avg(allResults.worker.totals);
      const hybridAvg = avg(allResults.hybrid.totals);
      const minAvg = Math.min(mainAvg, workerAvg, hybridAvg);
      const winner = minAvg === mainAvg ? 'MAIN' : minAvg === workerAvg ? 'WORKER' : 'HYBRID';

      log('\n' + '='.repeat(50));
      log(`WINNER: ${winner} (${minAvg.toFixed(2)}ms average)`);
      log('='.repeat(50));

      document.getElementById('comparison').style.display = 'grid';
      setProgress(`Complete! Winner: ${winner}`);

      btns.forEach(b => b.disabled = false);
      btn.textContent = 'Run All (Average)';
    };

    window.clearOPFS = async () => {
      log('Clearing OPFS storage...');
      await clearOPFS();
      log('OPFS storage cleared');
    };

    // Check OPFS support
    if (!navigator.storage?.getDirectory) {
      log('ERROR: OPFS is not supported in this browser!');
      document.getElementById('runMain').disabled = true;
      document.getElementById('runWorker').disabled = true;
      document.getElementById('runHybrid').disabled = true;
      document.getElementById('runAll').disabled = true;
    } else {
      log('OPFS is supported. Click buttons to run benchmarks.');
    }
  </script>
</body>
</html>
